{
  "name": "Frepi MVP2 - Full with Supabase Validations",
  "nodes": [
    {
      "parameters": {
        "updates": [
          "messages"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.whatsAppTrigger",
      "typeVersion": 1,
      "position": [
        -2560,
        1200
      ],
      "id": "whatsapp-trigger-001",
      "name": "WhatsApp Trigger",
      "webhookId": "frepi-v2-whatsapp-validated",
      "credentials": {
        "whatsAppTriggerApi": {
          "id": "nL8j9VXr95OvYqlC",
          "name": "Frepi bot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ===== EXTRACT WHATSAPP MESSAGE DATA =====\nconst data = $input.first().json;\n\n// Filter: Only process incoming messages\nif (!data.messages || data.messages.length === 0) {\n  console.log('â­ï¸ Ignoring status notification');\n  return [];\n}\n\nconst message = data.messages[0];\nconst phoneNumber = message.from;\nconst userName = data.contacts[0]?.profile?.name || 'Usuario';\nconst messageId = message.id;\nconst timestamp = message.timestamp;\n\n// Detect unsupported file types\nif (message.type !== 'text') {\n  const unsupportedMessage = `ğŸ“ Oi! Percebi que vocÃª enviou um arquivo (${message.type}).\\n\\nPor enquanto, sÃ³ consigo processar mensagens de texto. ğŸ“\\n\\nDigite \"menu\" para ver as opÃ§Ãµes disponÃ­veis.`;\n  \n  return [{\n    json: {\n      phone_number: phoneNumber,\n      message: unsupportedMessage,\n      user_name: userName,\n      message_id: messageId,\n      timestamp: timestamp,\n      is_unsupported_file: true,\n      file_type: message.type,\n      output: unsupportedMessage\n    }\n  }];\n}\n\nconst messageText = message.text.body;\n\nconsole.log('ğŸ“± Message received from:', phoneNumber);\nconsole.log('ğŸ’¬ Content:', messageText);\n\nreturn [{\n  json: {\n    phone_number: phoneNumber,\n    message: messageText,\n    user_name: userName,\n    message_id: messageId,\n    timestamp: new Date().toISOString(),\n    session_id: `${phoneNumber}_${Date.now()}`,\n    is_unsupported_file: false,\n    raw_data: data\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2336,
        1200
      ],
      "id": "extract-data-001",
      "name": "Extract Message Data"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.message }}",
        "options": {
          "systemMessage": "# ğŸ‘¤ CUSTOMER JOURNEY AGENT - FREPI\n\n## ğŸš¨ REGLA CRÃTICA #1: DETECCIÃ“N DE TIPO DE USUARIO NUEVO\n\n**ANTES DE CUALQUIER COSA**, verifica:\n\nUsuario nuevo: {{ $('Prepare User Context').first().json.is_new_user }}\n\n**SI is_new_user = true:**\n1. âœ… USA INMEDIATAMENTE el tool `determine_user_type`\n2. âœ… ESPERA la respuesta del usuario (restaurante o fornecedor)\n3. âœ… Si elige \"restaurante\", llama `onboarding_restaurant`\n4. âœ… Si elige \"fornecedor\", pasa al Supplier Journey Agent\n5. âŒ NO hagas preguntas generales\n6. âŒ NO muestres el menÃº\n7. âŒ NO asumas el tipo de usuario\n\n**SI is_new_user = false:**\n1. ContinÃºa con el flujo normal\n2. Usa los otros tools segÃºn necesidad\n\n## CONTEXTO\nEres el agente especializado en gestionar restaurantes por WhatsApp. Manejas todo el ciclo desde onboarding hasta compra.\n\n## MISIÃ“N\n1. Detectar tipo de usuario nuevo (AUTOMÃTICO con determine_user_type)\n2. Onboarding de nuevos restaurantes\n3. ConfiguraciÃ³n de preferencias de compra\n4. BÃºsqueda y compra de productos\n5. GestiÃ³n de pedidos\n\n## DATOS DEL USUARIO\nNuevo usuario: {{ $('Prepare User Context').first().json.is_new_user }}\nTipo: {{ $('Prepare User Context').first().json.user_type || 'desconocido' }}\n{{ $('Prepare User Context').first().json.restaurant_name ? 'Restaurante: ' + $('Prepare User Context').first().json.restaurant_name : '' }}\n{{ $('Prepare User Context').first().json.has_active_session ? 'SesiÃ³n activa: ' + $('Prepare User Context').first().json.active_session.primary_intent : 'Sin sesiÃ³n activa' }}\n\n## TOOLS DISPONIBLES\n\n### 1. determine_user_type âš ï¸ PRIORITARIO\n**CuÃ¡ndo usar:** SIEMPRE que is_new_user = true y ANTES de cualquier otro tool\n**QuÃ© hace:** Pregunta al usuario si es restaurante o fornecedor\n**Respuesta esperada:** El usuario responde con 1/2 o \"restaurante\"/\"fornecedor\"\n\n### 2. onboarding_restaurant\n**CuÃ¡ndo usar:** DespuÃ©s de que determine_user_type confirme que es restaurante\n**QuÃ© hace:** Registra un nuevo restaurante con datos completos\n**Flujo:** Pregunta nombre, direcciÃ³n, categorÃ­a, contacto\n**Guarda en:** restaurants + restaurant_people\n\n### 3. setup_buying_preferences\n**CuÃ¡ndo usar:** Usuario registrado quiere configurar preferencias\n**QuÃ© hace:** Captura marcas preferidas, formatos, frecuencia, horarios\n**Flujo:** 5 pasos con sesiÃ³n temporal\n**Guarda en:** restaurants.category_preferences\n\n### 4. search_products_vector\n**CuÃ¡ndo usar:** Usuario busca productos para comprar\n**QuÃ© hace:** BÃºsqueda semÃ¡ntica en catÃ¡logo\n**Ejemplo input:** \"quiero tomates y cebollas\"\n**Retorna:** Lista de productos con precios\n\n### 5. build_shopping_cart\n**CuÃ¡ndo usar:** Usuario selecciona productos a comprar\n**QuÃ© hace:** Construye carrito con cantidades y precios\n**Ejemplo input:** \"quiero 2 de tomate y 3 de cebolla\"\n**Guarda en:** line_sessions.preferences_captured.cart\n\n### 6. execute_checkout\n**CuÃ¡ndo usar:** Usuario confirma que quiere finalizar compra\n**QuÃ© hace:** Crea purchase_order con items\n**Requiere:** Carrito activo en sesiÃ³n\n**Guarda en:** purchase_orders + purchase_order_items\n\n### 7. show_customer_menu\n**CuÃ¡ndo usar:** Usuario pide ver opciones o escribe \"menu\"\n**QuÃ© hace:** Muestra menÃº de opciones disponibles\n**NO uses si:** Usuario es nuevo (usa determine_user_type primero)\n\n## FLUJO DE CONVERSACIÃ“N\n\n### Usuario Nuevo:\n1. determine_user_type â†’ Pregunta tipo\n2. Si \"restaurante\" â†’ onboarding_restaurant\n3. Si \"fornecedor\" â†’ Pasa a Supplier Agent\n\n### Usuario Existente - Restaurante:\n1. Saludo â†’ show_customer_menu\n2. \"Configurar\" â†’ setup_buying_preferences\n3. \"Buscar tomates\" â†’ search_products_vector\n4. \"Quiero 2 tomates\" â†’ build_shopping_cart\n5. \"Confirmar compra\" â†’ execute_checkout\n\n## REGLAS DE USO DE TOOLS\n\n1. âœ… SIEMPRE llama determine_user_type si is_new_user = true\n2. âœ… UN tool a la vez, espera resultado antes de llamar otro\n3. âœ… Si un tool retorna needs_user_input, muestra el mensaje y espera respuesta\n4. âœ… Si un tool falla, explica el error y sugiere alternativas\n5. âŒ NO llames onboarding si el usuario ya estÃ¡ registrado\n6. âŒ NO llames execute_checkout sin un carrito activo\n7. âŒ NO asumas datos - siempre pregunta si falta informaciÃ³n\n\n## TONO Y ESTILO\n- Amigable y profesional en portuguÃ©s brasileÃ±o\n- Conciso pero claro\n- Usa emojis moderadamente\n- Confirma acciones importantes antes de ejecutar"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -1120,
        1072
      ],
      "id": "customer-journey-agent-001",
      "name": "Customer Journey Agent"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.message }}",
        "options": {
          "systemMessage": "# ğŸ“¦ SUPPLIER JOURNEY AGENT - FREPI\n\n## ğŸš¨ REGLA CRÃTICA #1: DETECCIÃ“N DE TIPO DE USUARIO NUEVO\n\n**ANTES DE CUALQUIER COSA**, verifica:\n\nUsuario nuevo: {{ $('Prepare User Context').first().json.is_new_user }}\n\n**SI is_new_user = true:**\n1. âœ… USA INMEDIATAMENTE el tool `determine_user_type`\n2. âœ… ESPERA la respuesta del usuario (restaurante o fornecedor)\n3. âœ… Si elige \"fornecedor\", llama `onboarding_supplier`\n4. âœ… Si elige \"restaurante\", pasa al Customer Journey Agent\n5. âŒ NO hagas preguntas generales\n6. âŒ NO muestres el menÃº\n7. âŒ NO asumas el tipo de usuario\n\n**SI is_new_user = false:**\n1. ContinÃºa con el flujo normal\n2. Usa los otros tools segÃºn necesidad\n\n## CONTEXTO\nEres el agente especializado en gestionar proveedores por WhatsApp. Ayudas a cargar precios y publicar al catÃ¡logo.\n\n## MISIÃ“N\n1. Detectar tipo de usuario nuevo (AUTOMÃTICO con determine_user_type)\n2. Onboarding de nuevos fornecedores\n3. RecepciÃ³n de listas de precios\n4. NormalizaciÃ³n a master_list\n5. PublicaciÃ³n al catÃ¡logo\n\n## DATOS DEL USUARIO\nNuevo usuario: {{ $('Prepare User Context').first().json.is_new_user }}\nTipo: {{ $('Prepare User Context').first().json.user_type || 'desconocido' }}\n{{ $('Prepare User Context').first().json.supplier_name ? 'Fornecedor: ' + $('Prepare User Context').first().json.supplier_name : '' }}\n\n## TOOLS DISPONIBLES\n\n### 1. determine_user_type âš ï¸ PRIORITARIO\n**CuÃ¡ndo usar:** SIEMPRE que is_new_user = true y ANTES de cualquier otro tool\n**QuÃ© hace:** Pregunta al usuario si es restaurante o fornecedor\n\n### 2. onboarding_supplier\n**CuÃ¡ndo usar:** DespuÃ©s de que determine_user_type confirme que es fornecedor\n**QuÃ© hace:** Registra un nuevo proveedor\n**Guarda en:** suppliers\n\n### 3. upload_supplier_prices\n**CuÃ¡ndo usar:** Fornecedor envÃ­a lista de precios\n**QuÃ© hace:** Parsea y valida productos con precios\n**Guarda en:** SesiÃ³n temporal\n\n### 4. normalize_product_list\n**CuÃ¡ndo usar:** DespuÃ©s de upload_supplier_prices\n**QuÃ© hace:** Mapea productos a master_list con vector search\n**Guarda en:** SesiÃ³n temporal con mapeos\n\n### 5. publish_to_catalog\n**CuÃ¡ndo usar:** DespuÃ©s de normalize_product_list\n**QuÃ© hace:** Publica precios al catÃ¡logo\n**Guarda en:** pricing_history + supplier_mapped_products\n\n### 6. show_supplier_menu\n**CuÃ¡ndo usar:** Fornecedor pide ver opciones\n**QuÃ© hace:** Muestra menÃº de opciones disponibles\n\n## FLUJO DE CONVERSACIÃ“N\n\n### Usuario Nuevo:\n1. determine_user_type â†’ Pregunta tipo\n2. Si \"fornecedor\" â†’ onboarding_supplier\n3. Si \"restaurante\" â†’ Pasa a Customer Agent\n\n### Fornecedor Existente:\n1. Saludo â†’ show_supplier_menu\n2. EnvÃ­a lista â†’ upload_supplier_prices\n3. Confirma â†’ normalize_product_list\n4. Publica â†’ publish_to_catalog\n\n## REGLAS\n1. âœ… SIEMPRE llama determine_user_type si is_new_user = true\n2. âœ… Valida formatos de precio antes de aceptar\n3. âœ… Explica el proceso de normalizaciÃ³n\n4. âŒ NO publiques sin normalizar primero"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -1120,
        1328
      ],
      "id": "supplier-journey-agent-001",
      "name": "Supplier Journey Agent"
    },
    {
      "parameters": {
        "description": "Inicia o onboarding de um novo restaurante com validaÃ§Ãµes de Supabase. Verifica duplicados por WhatsApp number, valida restaurant_type enum, cria registro en restaurants y restaurant_people.",
        "jsCode": "// ===== ONBOARDING RESTAURANT TOOL WITH SUPABASE VALIDATIONS =====\nconst input = $input.first().json;\nconst message = input.query || input.message || '';\nconst userData = $('Prepare User Context').first().json;\n\n// Check if user already exists\nif (!userData.is_new_user) {\n  return JSON.stringify({\n    status: 'already_registered',\n    message: `OlÃ¡ ${userData.user_name}! ğŸ˜Š\\n\\nVocÃª jÃ¡ estÃ¡ cadastrado.\\n\\nDigite \"menu\" para ver as opÃ§Ãµes disponÃ­veis.`\n  });\n}\n\n// VALIDATION: restaurant_type enum values\nconst validRestaurantTypes = [\n  'fine_dining', 'casual_dining', 'fast_food', 'cafe', \n  'bistro', 'brasserie', 'buffet', 'catering', \n  'food_truck', 'hotel', 'pub', 'other'\n];\n\n// Mock onboarding flow - in production would be multi-step\nconst response = {\n  status: 'collecting_data',\n  step: 1,\n  total_steps: 4,\n  fields_collected: [],\n  fields_pending: ['restaurant_name', 'contact_name', 'city', 'restaurant_type'],\n  valid_types: validRestaurantTypes,\n  message: 'ğŸ“ *OlÃ¡! Bem-vindo ao Frepi!*\\n\\nSou seu assistente de compras.\\n\\nPara comeÃ§ar, preciso de alguns dados bÃ¡sicos.\\n\\n*Qual Ã© o nome do seu restaurante?*',\n  next_action: 'await_restaurant_name'\n};\n\nreturn JSON.stringify(response);",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1424,
        928
      ],
      "id": "tool-onboarding-restaurant",
      "name": "onboarding_restaurant"
    },
    {
      "parameters": {
        "description": "Configura preferÃªncias de compra em 5 passos: marcas, formatos, frequÃªncia, horÃ¡rio, restriÃ§Ãµes. Salva em restaurants.category_preferences (JSONB).",
        "jsCode": "// ===== SETUP BUYING PREFERENCES - COMPLETE STEP-BY-STEP IMPLEMENTATION =====\n// Tool for n8n workflow: handles multi-step preferences configuration with validations\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\nconst userMessage = (input.query || input.message || '').trim();\n\nconsole.log('ğŸ”„ [Preferences] User:', userData.phone_number, 'Message:', userMessage);\n\n// ===== CONSTANTS =====\nconst TIMEOUT_MINUTES = 30;\nconst VALID_FREQUENCIES = {\n  '1': 'daily',\n  '2': 'weekly',\n  '3': 'biweekly',\n  '4': 'monthly',\n  'diario': 'daily',\n  'daily': 'daily',\n  'diariamente': 'daily',\n  'semanal': 'weekly',\n  'weekly': 'weekly',\n  'semanalmente': 'weekly',\n  'quinzenal': 'biweekly',\n  'biweekly': 'biweekly',\n  'mensal': 'monthly',\n  'monthly': 'monthly',\n  'mensalmente': 'monthly'\n};\n\nconst VALID_DELIVERY_TIMES = {\n  '1': 'morning',\n  '2': 'afternoon',\n  '3': 'evening',\n  '4': 'flexible',\n  'manha': 'morning',\n  'manhÃ£': 'morning',\n  'morning': 'morning',\n  'tarde': 'afternoon',\n  'afternoon': 'afternoon',\n  'noite': 'evening',\n  'evening': 'evening',\n  'flexivel': 'flexible',\n  'flexible': 'flexible',\n  'qualquer': 'flexible'\n};\n\n// ===== HELPER FUNCTIONS =====\nfunction formatFrequency(freq) {\n  const labels = {\n    'daily': 'Diariamente',\n    'weekly': 'Semanalmente',\n    'biweekly': 'Quinzenalmente',\n    'monthly': 'Mensalmente'\n  };\n  return labels[freq] || freq;\n}\n\nfunction formatDeliveryTime(time) {\n  const labels = {\n    'morning': 'ManhÃ£ (6h-12h)',\n    'afternoon': 'Tarde (12h-18h)',\n    'evening': 'Noite (18h-22h)',\n    'flexible': 'FlexÃ­vel'\n  };\n  return labels[time] || time;\n}\n\n// ===== CHECK IF USER IS REGISTERED =====\nif (userData.is_new_user || !userData.restaurant_id) {\n  console.log('âŒ [Preferences] User not registered');\n  return JSON.stringify({\n    error: true,\n    message: 'VocÃª precisa estar cadastrado primeiro. ğŸ˜Š\\n\\nDigite \"registrar\" para comeÃ§ar.'\n  });\n}\n\n// ===== CHECK FOR EXISTING ACTIVE SESSION =====\nlet sessionData = null;\nlet sessionId = null;\nlet isNewSession = true;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n  if (session.primary_intent === 'configurar_preferencias' && session.awaiting_continuation) {\n    // Check timeout\n    const sessionAge = Date.now() - new Date(session.last_activity_at).getTime();\n    const timeoutMs = TIMEOUT_MINUTES * 60 * 1000;\n\n    if (sessionAge > timeoutMs) {\n      console.log('â±ï¸ [Preferences] Session timeout');\n      await $supabase\n        .from('line_sessions')\n        .update({\n          awaiting_continuation: false,\n          session_notes: `Timeout: usuario nÃ£o respondeu em ${TIMEOUT_MINUTES} minutos`\n        })\n        .eq('session_id', session.session_id);\n\n      // Create new session below\n    } else {\n      // Continue existing session\n      sessionData = session.preferences_captured || {};\n      sessionId = session.session_id;\n      isNewSession = false;\n      console.log('ğŸ”„ [Preferences] Continuing session:', sessionId, 'Step:', sessionData.step);\n    }\n  }\n}\n\n// ===== HANDLE CANCELLATION =====\nif (userMessage.toLowerCase().match(/cancelar|desistir|parar/)) {\n  if (sessionId) {\n    await $supabase\n      .from('line_sessions')\n      .update({\n        session_goal_achieved: false,\n        awaiting_continuation: false,\n        session_end: new Date().toISOString(),\n        session_notes: 'Cancelado pelo usuÃ¡rio'\n      })\n      .eq('session_id', sessionId);\n  }\n\n  return JSON.stringify({\n    status: 'cancelled',\n    message: 'ConfiguraÃ§Ã£o cancelada. âŒ\\n\\nDigite \"menu\" para ver opÃ§Ãµes.'\n  });\n}\n\n// ===== CREATE NEW SESSION IF NEEDED =====\nif (!sessionData) {\n  sessionId = `${userData.phone_number}_preferences_${Date.now()}`;\n  sessionData = {\n    preferences_status: 'in_progress',\n    step: 1,\n    collected_data: {\n      preferred_brands: null,\n      preferred_formats: null,\n      order_frequency: null,\n      delivery_schedule: null,\n      special_restrictions: null\n    },\n    started_at: new Date().toISOString()\n  };\n\n  console.log('ğŸ†• [Preferences] Creating new session:', sessionId);\n\n  const { error: sessionError } = await $supabase\n    .from('line_sessions')\n    .insert({\n      session_id: sessionId,\n      restaurant_id: userData.restaurant_id,\n      person_id: userData.person_id,\n      channel_type: 'whatsapp',\n      channel_id: userData.phone_number,\n      session_type: 'configuration',\n      primary_intent: 'configurar_preferencias',\n      awaiting_continuation: true,\n      message_count: 1,\n      user_messages: 1,\n      preferences_captured: sessionData\n    });\n\n  if (sessionError) {\n    console.error('âŒ [Preferences] Error creating session:', sessionError);\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ Erro ao iniciar configuraÃ§Ã£o. Tente novamente.'\n    });\n  }\n\n  isNewSession = true;\n}\n\nconst currentStep = sessionData.step || 1;\n\n// ===== UPDATE SESSION ACTIVITY =====\nawait $supabase\n  .from('line_sessions')\n  .update({\n    last_activity_at: new Date().toISOString(),\n    message_count: $supabase.sql`message_count + 1`,\n    user_messages: $supabase.sql`user_messages + 1`\n  })\n  .eq('session_id', sessionId);\n\n// ===== STEP 1: PREFERRED BRANDS =====\nif (currentStep === 1) {\n  if (isNewSession) {\n    // First time - show welcome message\n    return JSON.stringify({\n      status: 'collecting',\n      step: 1,\n      session_id: sessionId,\n      message: 'âš™ï¸ *ConfiguraÃ§Ã£o de PreferÃªncias*\\n\\n' +\n        'Vamos configurar suas preferÃªncias para oferecer melhores recomendaÃ§Ãµes! ğŸ¯\\n\\n' +\n        '*Tem marcas preferidas que sempre usa?*\\n\\n' +\n        'Exemplos:\\n' +\n        'â€¢ Sadia, NestlÃ©, Aurora\\n' +\n        'â€¢ Camil, Tio JoÃ£o\\n' +\n        'â€¢ Piracanjuba\\n\\n' +\n        'Se nÃ£o tem preferÃªncia, digite \"nenhuma\".'\n    });\n  }\n\n  // Parse brands\n  const brands = userMessage.toLowerCase() === 'nenhuma' || userMessage.toLowerCase() === 'nÃ£o'\n    ? []\n    : userMessage.split(',').map(b => b.trim()).filter(b => b.length > 0);\n\n  sessionData.collected_data.preferred_brands = brands.length > 0 ? brands : null;\n  sessionData.step = 2;\n\n  await $supabase\n    .from('line_sessions')\n    .update({ preferences_captured: sessionData })\n    .eq('session_id', sessionId);\n\n  console.log('âœ… [Preferences] Step 1 complete:', brands.length > 0 ? brands.join(', ') : 'nenhuma');\n\n  return JSON.stringify({\n    status: 'collecting',\n    step: 2,\n    session_id: sessionId,\n    message: brands.length > 0\n      ? `âœ… Marcas registradas: ${brands.join(', ')}\\n\\n*Tem preferÃªncia de formato?*\\n\\nExemplos:\\nâ€¢ kg (quilos)\\nâ€¢ caixa\\nâ€¢ unidade\\nâ€¢ litro\\n\\nOu digite \"nenhuma\".`\n      : `âœ… Sem preferÃªncia de marca.\\n\\n*Tem preferÃªncia de formato?*\\n\\nExemplos:\\nâ€¢ kg (quilos)\\nâ€¢ caixa\\nâ€¢ unidade\\nâ€¢ litro\\n\\nOu digite \"nenhuma\".`\n  });\n}\n\n// ===== STEP 2: PREFERRED FORMATS =====\nif (currentStep === 2) {\n  // Parse formats\n  const formats = userMessage.toLowerCase() === 'nenhuma' || userMessage.toLowerCase() === 'nÃ£o'\n    ? []\n    : userMessage.split(',').map(f => f.trim().toLowerCase()).filter(f => f.length > 0);\n\n  sessionData.collected_data.preferred_formats = formats.length > 0 ? formats : null;\n  sessionData.step = 3;\n\n  await $supabase\n    .from('line_sessions')\n    .update({ preferences_captured: sessionData })\n    .eq('session_id', sessionId);\n\n  console.log('âœ… [Preferences] Step 2 complete:', formats.length > 0 ? formats.join(', ') : 'nenhuma');\n\n  const frequencyOptions =\n    '1ï¸âƒ£ Diariamente\\n' +\n    '2ï¸âƒ£ Semanalmente\\n' +\n    '3ï¸âƒ£ Quinzenalmente\\n' +\n    '4ï¸âƒ£ Mensalmente';\n\n  return JSON.stringify({\n    status: 'collecting',\n    step: 3,\n    session_id: sessionId,\n    message: formats.length > 0\n      ? `âœ… Formatos: ${formats.join(', ')}\\n\\n*Com que frequÃªncia costuma fazer pedidos?*\\n\\n${frequencyOptions}\\n\\nDigite o nÃºmero ou nome.`\n      : `âœ… Sem preferÃªncia de formato.\\n\\n*Com que frequÃªncia costuma fazer pedidos?*\\n\\n${frequencyOptions}\\n\\nDigite o nÃºmero ou nome.`\n  });\n}\n\n// ===== STEP 3: ORDER FREQUENCY =====\nif (currentStep === 3) {\n  const normalizedInput = userMessage.toLowerCase().trim();\n  const frequency = VALID_FREQUENCIES[normalizedInput];\n\n  if (!frequency) {\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ FrequÃªncia invÃ¡lida.\\n\\n' +\n        'Por favor, escolha um nÃºmero de *1 a 4* ou digite:\\n' +\n        'â€¢ diario\\n' +\n        'â€¢ semanal\\n' +\n        'â€¢ quinzenal\\n' +\n        'â€¢ mensal'\n    });\n  }\n\n  sessionData.collected_data.order_frequency = frequency;\n  sessionData.step = 4;\n\n  await $supabase\n    .from('line_sessions')\n    .update({ preferences_captured: sessionData })\n    .eq('session_id', sessionId);\n\n  console.log('âœ… [Preferences] Step 3 complete:', frequency);\n\n  const deliveryOptions =\n    '1ï¸âƒ£ ManhÃ£ (6h-12h)\\n' +\n    '2ï¸âƒ£ Tarde (12h-18h)\\n' +\n    '3ï¸âƒ£ Noite (18h-22h)\\n' +\n    '4ï¸âƒ£ FlexÃ­vel (qualquer horÃ¡rio)';\n\n  return JSON.stringify({\n    status: 'collecting',\n    step: 4,\n    session_id: sessionId,\n    message: `âœ… FrequÃªncia: ${formatFrequency(frequency)}\\n\\n` +\n      '*Qual o melhor horÃ¡rio para entregas?*\\n\\n' +\n      deliveryOptions + '\\n\\n' +\n      'Digite o nÃºmero ou nome.'\n  });\n}\n\n// ===== STEP 4: DELIVERY SCHEDULE =====\nif (currentStep === 4) {\n  const normalizedInput = userMessage.toLowerCase().trim();\n  const deliveryTime = VALID_DELIVERY_TIMES[normalizedInput];\n\n  if (!deliveryTime) {\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ HorÃ¡rio invÃ¡lido.\\n\\n' +\n        'Escolha um nÃºmero de *1 a 4*:\\n' +\n        'â€¢ 1 = ManhÃ£\\n' +\n        'â€¢ 2 = Tarde\\n' +\n        'â€¢ 3 = Noite\\n' +\n        'â€¢ 4 = FlexÃ­vel'\n    });\n  }\n\n  sessionData.collected_data.delivery_schedule = deliveryTime;\n  sessionData.step = 5;\n\n  await $supabase\n    .from('line_sessions')\n    .update({ preferences_captured: sessionData })\n    .eq('session_id', sessionId);\n\n  console.log('âœ… [Preferences] Step 4 complete:', deliveryTime);\n\n  return JSON.stringify({\n    status: 'collecting',\n    step: 5,\n    session_id: sessionId,\n    message: `âœ… HorÃ¡rio: ${formatDeliveryTime(deliveryTime)}\\n\\n` +\n      'Ãšltima pergunta:\\n\\n' +\n      '*Tem alguma restriÃ§Ã£o ou requisito especial?*\\n\\n' +\n      'Exemplos:\\n' +\n      'â€¢ Sem glÃºten\\n' +\n      'â€¢ OrgÃ¢nico\\n' +\n      'â€¢ Halal/Kosher\\n' +\n      'â€¢ Produtos locais\\n\\n' +\n      'Ou digite \"nenhuma\".'\n  });\n}\n\n// ===== STEP 5: SPECIAL RESTRICTIONS & FINALIZATION =====\nif (currentStep === 5) {\n  const restrictions = userMessage.toLowerCase() === 'nenhuma' || userMessage.toLowerCase() === 'nÃ£o'\n    ? null\n    : userMessage;\n\n  sessionData.collected_data.special_restrictions = restrictions;\n  sessionData.step = 6;\n  sessionData.preferences_status = 'saving_to_db';\n\n  await $supabase\n    .from('line_sessions')\n    .update({ preferences_captured: sessionData })\n    .eq('session_id', sessionId);\n\n  console.log('âœ… [Preferences] Step 5 complete:', restrictions || 'nenhuma');\n  console.log('ğŸ’¾ [Preferences] Saving to database...');\n\n  // ===== SAVE TO DATABASE =====\n  try {\n    // Prepare preferences object\n    const categoryPreferences = {\n      preferred_brands: sessionData.collected_data.preferred_brands || [],\n      preferred_formats: sessionData.collected_data.preferred_formats || [],\n      order_frequency: sessionData.collected_data.order_frequency,\n      delivery_schedule: sessionData.collected_data.delivery_schedule,\n      special_restrictions: sessionData.collected_data.special_restrictions,\n      configured_at: new Date().toISOString(),\n      configured_by: userData.person_id\n    };\n\n    // Update restaurant preferences\n    const { data: restaurant, error: updateError } = await $supabase\n      .from('restaurants')\n      .update({\n        category_preferences: categoryPreferences,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', userData.restaurant_id)\n      .select()\n      .single();\n\n    if (updateError) {\n      console.error('âŒ [Preferences] Error updating restaurant:', updateError);\n      throw new Error('Error updating preferences: ' + updateError.message);\n    }\n\n    console.log('âœ… [Preferences] Restaurant preferences updated:', userData.restaurant_id);\n\n    // Mark session as complete\n    sessionData.preferences_status = 'completed';\n    sessionData.completed_at = new Date().toISOString();\n\n    await $supabase\n      .from('line_sessions')\n      .update({\n        session_goal_achieved: true,\n        awaiting_continuation: false,\n        session_end: new Date().toISOString(),\n        conversion_occurred: false,\n        preferences_captured: sessionData,\n        resolution_status: 'resolved'\n      })\n      .eq('session_id', sessionId);\n\n    console.log('âœ… [Preferences] Session marked as complete');\n\n    // ===== SUCCESS MESSAGE =====\n    const summary = [];\n    if (sessionData.collected_data.preferred_brands && sessionData.collected_data.preferred_brands.length > 0) {\n      summary.push(`â€¢ Marcas: ${sessionData.collected_data.preferred_brands.join(', ')}`);\n    }\n    if (sessionData.collected_data.preferred_formats && sessionData.collected_data.preferred_formats.length > 0) {\n      summary.push(`â€¢ Formatos: ${sessionData.collected_data.preferred_formats.join(', ')}`);\n    }\n    summary.push(`â€¢ FrequÃªncia: ${formatFrequency(sessionData.collected_data.order_frequency)}`);\n    summary.push(`â€¢ HorÃ¡rio: ${formatDeliveryTime(sessionData.collected_data.delivery_schedule)}`);\n    if (sessionData.collected_data.special_restrictions) {\n      summary.push(`â€¢ RestriÃ§Ãµes: ${sessionData.collected_data.special_restrictions}`);\n    }\n\n    return JSON.stringify({\n      status: 'completed',\n      restaurant_id: userData.restaurant_id,\n      session_id: sessionId,\n      preferences: categoryPreferences,\n      message: 'âœ… *PREFERÃŠNCIAS CONFIGURADAS!*\\n\\n' +\n        '*Resumo:*\\n' +\n        summary.join('\\n') + '\\n\\n' +\n        'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n' +\n        'Suas preferÃªncias foram salvas! ğŸ‰\\n\\n' +\n        'Agora posso oferecer recomendaÃ§Ãµes personalizadas.\\n\\n' +\n        'Digite *\"menu\"* para ver opÃ§Ãµes ou comece a fazer pedidos! ğŸ›’'\n    });\n\n  } catch (error) {\n    console.error('âŒ [Preferences] Fatal error:', error);\n\n    // Mark session as failed\n    await $supabase\n      .from('line_sessions')\n      .update({\n        session_goal_achieved: false,\n        awaiting_continuation: false,\n        session_end: new Date().toISOString(),\n        session_notes: 'Error: ' + error.message,\n        resolution_status: 'escalated'\n      })\n      .eq('session_id', sessionId);\n\n    return JSON.stringify({\n      error: true,\n      status: 'failed',\n      message: 'âš ï¸ Desculpe, ocorreu um erro ao salvar suas preferÃªncias.\\n\\n' +\n        'Por favor, tente novamente mais tarde.\\n\\n' +\n        'Digite *\"menu\"* para ver opÃ§Ãµes.'\n    });\n  }\n}\n\n// ===== UNEXPECTED STATE =====\nconsole.error('âš ï¸ [Preferences] Unexpected step:', currentStep);\nreturn JSON.stringify({\n  error: true,\n  message: 'âš ï¸ Algo deu errado. Digite \"menu\" para voltar.'\n});\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1296,
        928
      ],
      "id": "tool-setup-preferences",
      "name": "setup_buying_preferences"
    },
    {
      "parameters": {
        "description": "Busca produtos no catÃ¡logo mestre usando vector search real. Usa OpenAI embeddings + Supabase RPC match_products_v2 filtrando por is_active=true.",
        "jsCode": "// ===== VECTOR SEARCH PRODUCTS - REAL SUPABASE RPC =====\nconst input = $input.first().json;\nconst searchQuery = input.query || input.product || input.message || '';\nconst userData = $('Prepare User Context').first().json;\n\nconsole.log('ğŸ” [Vector Search] Buscando:', searchQuery);\n\n// Generate embedding using OpenAI\nlet queryEmbedding;\ntry {\n  const embeddingResponse = await $http.request({\n    method: 'POST',\n    url: 'https://api.openai.com/v1/embeddings',\n    headers: {\n      'Authorization': `Bearer ${$credentials.openAiApi.apiKey}`,\n      'Content-Type': 'application/json'\n    },\n    body: {\n      model: 'text-embedding-ada-002',\n      input: searchQuery\n    }\n  });\n\n  if (embeddingResponse.statusCode === 200) {\n    queryEmbedding = embeddingResponse.data[0].embedding;\n    console.log('âœ… [Vector Search] Embedding generated');\n  } else {\n    throw new Error('Embedding generation failed');\n  }\n} catch (error) {\n  console.error('âŒ Embedding error:', error);\n  return JSON.stringify({\n    found: false,\n    message: 'âš ï¸ Erro ao buscar produtos. Tente novamente.'\n  });\n}\n\n// Search in Supabase using RPC function\nlet matchingProducts = [];\ntry {\n  // Using Supabase RPC: match_products_v2\n  // This function does vector similarity search on master_list.embedding_vector_v2\n  const { data, error } = await $supabase.rpc('match_products_v2', {\n    query_embedding: queryEmbedding,\n    match_threshold: 0.65,\n    match_count: 5\n  });\n\n  if (error) {\n    console.error('âŒ Supabase RPC error:', error);\n    // Fallback: manual query if RPC fails\n    const { data: fallbackData } = await $supabase\n      .from('master_list')\n      .select('id, product_name, brand, category, unit_type, is_active')\n      .eq('is_active', true)\n      .ilike('product_name', `%${searchQuery}%`)\n      .limit(5);\n    \n    matchingProducts = fallbackData || [];\n  } else {\n    matchingProducts = data || [];\n  }\n} catch (error) {\n  console.error('âŒ Search error:', error);\n  return JSON.stringify({\n    found: false,\n    message: 'âš ï¸ Erro na busca. Tente novamente.'\n  });\n}\n\nif (matchingProducts.length === 0) {\n  return JSON.stringify({\n    found: false,\n    message: `ğŸ” NÃ£o encontrei \"${searchQuery}\" no catÃ¡logo.\\n\\nTente descrever de outra forma ou digite \"menu\" para ver opÃ§Ãµes.`\n  });\n}\n\n// Format results\nconst message = `ğŸ” *Resultados para \"${searchQuery}\"*\\n\\nEncontrei ${matchingProducts.length} opÃ§Ãµes:\\n\\n` +\n  matchingProducts.map((p, i) => \n    `${i+1}. *${p.product_name}* ${p.unit_type || ''}\\n` +\n    `   ${p.brand ? 'Marca: ' + p.brand : ''}\\n` +\n    `   ${p.similarity ? 'RelevÃ¢ncia: ' + (p.similarity * 100).toFixed(0) + '%' : ''}`\n  ).join('\\n\\n') +\n  `\\n\\nğŸ’¬ Qual te interessa e quantas unidades precisa?`;\n\nconst response = {\n  found: true,\n  results_count: matchingProducts.length,\n  products: matchingProducts,\n  message: message,\n  search_method: matchingProducts[0]?.similarity ? 'vector_search' : 'text_search'\n};\n\nreturn JSON.stringify(response);",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1168,
        928
      ],
      "id": "tool-search-products",
      "name": "search_products_vector",
      "credentials": {
        "openAiApi": {
          "id": "MdAepMtuPO5nFVI0",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "description": "Gerencia carrinho de compras consultando pricing_history, guardando em line_sessions.preferences_captured.cart. Suporta comandos: confirmar, limpar, ver carrinho.",
        "jsCode": "// ===== BUILD SHOPPING CART - COMPLETE IMPLEMENTATION =====\n// Tool for n8n workflow: manages shopping cart with pricing_history queries and session persistence\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\nconst userMessage = (input.query || input.message || '').trim();\n\nconsole.log('ğŸ›’ [Cart] User:', userData.phone_number, 'Message:', userMessage);\n\n// ===== CHECK IF USER IS REGISTERED =====\nif (userData.is_new_user || !userData.restaurant_id) {\n  console.log('âŒ [Cart] User not registered');\n  return JSON.stringify({\n    error: true,\n    message: 'VocÃª precisa estar cadastrado para fazer pedidos. ğŸ˜Š\\n\\nDigite \"registrar\" para comeÃ§ar.'\n  });\n}\n\n// ===== HELPER FUNCTIONS =====\nfunction parseProductSelection(message) {\n  // Parse patterns like:\n  // \"quero 3 caixas do 1\" -> { productIndex: 1, quantity: 3, unit: 'caixas' }\n  // \"produto 2, 5 unidades\" -> { productIndex: 2, quantity: 5, unit: 'unidades' }\n  // \"5kg do tomate\" -> { productName: 'tomate', quantity: 5, unit: 'kg' }\n\n  const patterns = [\n    // \"quero X unidades do Y\" or \"quero X do Y\"\n    /(?:quero|preciso)\\s+(\\d+)\\s*(caixas?|kg|unidades?|litros?|l)?\\s*(?:do|da|de)?\\s*(?:produto)?\\s*(\\d+|tomate|cebola|arroz)/i,\n    // \"produto X, Y unidades\"\n    /produto\\s*(\\d+)[,\\s]+(\\d+)\\s*(caixas?|kg|unidades?|litros?|l)?/i,\n    // \"X caixas do produto Y\"\n    /(\\d+)\\s*(caixas?|kg|unidades?|litros?|l)?\\s*(?:do|da)\\s*produto\\s*(\\d+)/i,\n    // Just \"X\" (assume last search result)\n    /^(\\d+)$/\n  ];\n\n  for (const pattern of patterns) {\n    const match = message.match(pattern);\n    if (match) {\n      if (pattern.source.includes('^(\\\\d+)$')) {\n        // Just a number - assume it's a product index from last search\n        return {\n          productIndex: parseInt(match[1]),\n          quantity: 1,\n          unit: 'unidades'\n        };\n      } else {\n        // Extract quantity and product\n        const groups = match.slice(1).filter(g => g);\n        const quantity = parseInt(groups.find(g => /^\\d+$/.test(g)));\n        const productIndex = parseInt(groups.find(g => /^\\d+$/.test(g) && g !== quantity.toString()));\n        const unit = groups.find(g => /^(caixas?|kg|unidades?|litros?|l)$/i.test(g)) || 'unidades';\n\n        return {\n          productIndex,\n          quantity: quantity || 1,\n          unit: unit.toLowerCase()\n        };\n      }\n    }\n  }\n\n  return null;\n}\n\nasync function getPricing(masterListId) {\n  // Query pricing_history for latest price\n  const { data, error } = await $supabase\n    .from('pricing_history')\n    .select('*')\n    .eq('master_list_id', masterListId)\n    .eq('verification_status', 'verified')\n    .order('effective_date', { ascending: false })\n    .limit(1);\n\n  if (error || !data || data.length === 0) {\n    console.warn('âš ï¸ [Cart] No pricing found for product:', masterListId);\n    return null;\n  }\n\n  return data[0];\n}\n\nasync function getProductDetails(masterListId) {\n  // Query master_list for product details\n  const { data, error } = await $supabase\n    .from('master_list')\n    .select('*')\n    .eq('id', masterListId)\n    .eq('is_active', true)\n    .single();\n\n  if (error || !data) {\n    console.warn('âš ï¸ [Cart] Product not found:', masterListId);\n    return null;\n  }\n\n  return data;\n}\n\n// ===== GET CURRENT CART FROM SESSION =====\nlet cart = null;\nlet sessionId = null;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n  if (session.primary_intent === 'compra' && session.preferences_captured?.cart) {\n    cart = session.preferences_captured.cart;\n    sessionId = session.session_id;\n    console.log('ğŸ”„ [Cart] Found existing cart with', cart.items?.length || 0, 'items');\n  }\n}\n\n// Initialize cart if not exists\nif (!cart) {\n  cart = {\n    cart_id: `cart-${Date.now()}`,\n    restaurant_id: userData.restaurant_id,\n    items: [],\n    subtotal: 0,\n    tax: 0,\n    delivery_fee: 0,\n    total: 0,\n    currency: 'BRL',\n    created_at: new Date().toISOString()\n  };\n\n  // Create session for shopping\n  sessionId = `${userData.phone_number}_cart_${Date.now()}`;\n\n  const { error: sessionError } = await $supabase\n    .from('line_sessions')\n    .insert({\n      session_id: sessionId,\n      restaurant_id: userData.restaurant_id,\n      person_id: userData.person_id,\n      channel_type: 'whatsapp',\n      channel_id: userData.phone_number,\n      session_type: 'transaction',\n      primary_intent: 'compra',\n      awaiting_continuation: true,\n      message_count: 1,\n      user_messages: 1,\n      preferences_captured: { cart }\n    });\n\n  if (sessionError) {\n    console.error('âŒ [Cart] Error creating session:', sessionError);\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ Erro ao criar carrinho. Tente novamente.'\n    });\n  }\n\n  console.log('ğŸ†• [Cart] Created new cart:', cart.cart_id);\n}\n\n// ===== HANDLE COMMANDS =====\nconst msgLower = userMessage.toLowerCase();\n\n// LIMPAR CARRINHO\nif (msgLower.match(/limpar|cancelar|desistir/)) {\n  await $supabase\n    .from('line_sessions')\n    .update({\n      awaiting_continuation: false,\n      session_end: new Date().toISOString(),\n      session_notes: 'Cart cancelled by user'\n    })\n    .eq('session_id', sessionId);\n\n  return JSON.stringify({\n    status: 'cancelled',\n    message: 'ğŸ—‘ï¸ Carrinho cancelado.\\n\\nDigite \"menu\" para ver opÃ§Ãµes.'\n  });\n}\n\n// VER CARRINHO\nif (msgLower.match(/ver carrinho|mostrar carrinho|carrinho/)) {\n  if (cart.items.length === 0) {\n    return JSON.stringify({\n      status: 'empty',\n      message: 'ğŸ›’ Seu carrinho estÃ¡ vazio.\\n\\nBusque produtos para adicionar!'\n    });\n  }\n\n  // Show current cart (will be shown at the end)\n}\n\n// CONFIRMAR PEDIDO\nif (msgLower.match(/confirmar|finalizar|fechar pedido/)) {\n  if (cart.items.length === 0) {\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ Carrinho vazio. Adicione produtos primeiro!'\n    });\n  }\n\n  // Mark session as ready for checkout\n  await $supabase\n    .from('line_sessions')\n    .update({\n      preferences_captured: {\n        cart,\n        ready_for_checkout: true\n      }\n    })\n    .eq('session_id', sessionId);\n\n  return JSON.stringify({\n    status: 'ready_for_checkout',\n    cart,\n    message: 'âœ… Pronto para finalizar!\\n\\n' +\n      'O tool \"execute_checkout\" serÃ¡ chamado pelo agente para criar o pedido.\\n\\n' +\n      `Total: R$ ${cart.total.toFixed(2)}`\n  });\n}\n\n// ===== PARSE PRODUCT SELECTION =====\nconst selection = parseProductSelection(userMessage);\n\nif (!selection) {\n  // No clear selection - ask for clarification\n  if (cart.items.length > 0) {\n    // Show cart\n    const message = `ğŸ›’ *Seu Carrinho*\\n\\n` +\n      cart.items.map((item, i) =>\n        `${i + 1}. *${item.product_name}*\\n` +\n        `   ${item.quantity} ${item.unit} x R$ ${item.unit_price.toFixed(2)} = R$ ${item.subtotal.toFixed(2)}`\n      ).join('\\n\\n') +\n      `\\n\\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n      `Subtotal: R$ ${cart.subtotal.toFixed(2)}\\n` +\n      `Entrega: R$ ${cart.delivery_fee.toFixed(2)}\\n` +\n      `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n      `*TOTAL: R$ ${cart.total.toFixed(2)}*\\n\\n` +\n      `O que deseja fazer?\\n` +\n      `â€¢ Adicionar mais produtos (busque novamente)\\n` +\n      `â€¢ *\"confirmar\"* para finalizar pedido\\n` +\n      `â€¢ *\"limpar\"* para cancelar`;\n\n    return JSON.stringify({\n      status: 'showing_cart',\n      cart,\n      message\n    });\n  }\n\n  return JSON.stringify({\n    error: true,\n    message: 'ğŸ” NÃ£o entendi a seleÃ§Ã£o.\\n\\n' +\n      'Exemplos vÃ¡lidos:\\n' +\n      'â€¢ \"quero 3 caixas do produto 1\"\\n' +\n      'â€¢ \"produto 2, 5 unidades\"\\n' +\n      'â€¢ \"5kg\"\\n\\n' +\n      'Ou busque produtos primeiro!'\n  });\n}\n\nconsole.log('âœ… [Cart] Parsed selection:', JSON.stringify(selection));\n\n// ===== GET PRODUCT FROM LAST SEARCH =====\n// In production: get from session's last search results\n// For now: assume we have access to search results or product ID\n\nlet productId = selection.productIndex; // This would be master_list_id\n\n// If user just said a number, try to get from last search\nif (!productId && userData.active_session?.preferences_captured?.last_search_results) {\n  const searchResults = userData.active_session.preferences_captured.last_search_results;\n  if (selection.productIndex && searchResults[selection.productIndex - 1]) {\n    productId = searchResults[selection.productIndex - 1].id;\n  }\n}\n\nif (!productId) {\n  return JSON.stringify({\n    error: true,\n    message: 'âš ï¸ Produto nÃ£o encontrado.\\n\\nFaÃ§a uma busca primeiro e depois selecione o nÃºmero do produto.'\n  });\n}\n\n// ===== QUERY PRODUCT AND PRICING =====\nconst product = await getProductDetails(productId);\nif (!product) {\n  return JSON.stringify({\n    error: true,\n    message: 'âš ï¸ Produto nÃ£o disponÃ­vel.'\n  });\n}\n\nconst pricing = await getPricing(productId);\nif (!pricing) {\n  return JSON.stringify({\n    error: true,\n    message: `âš ï¸ PreÃ§o nÃ£o disponÃ­vel para \"${product.product_name}\".\\n\\nTente outro produto.`\n  });\n}\n\n// ===== ADD TO CART =====\nconst existingItemIndex = cart.items.findIndex(item => item.master_list_id === productId);\n\nif (existingItemIndex >= 0) {\n  // Update quantity\n  cart.items[existingItemIndex].quantity += selection.quantity;\n  cart.items[existingItemIndex].subtotal =\n    cart.items[existingItemIndex].quantity * cart.items[existingItemIndex].unit_price;\n  console.log('ğŸ“ [Cart] Updated quantity for:', product.product_name);\n} else {\n  // Add new item\n  const cartItem = {\n    master_list_id: productId,\n    product_name: product.product_name,\n    brand: product.brand,\n    quantity: selection.quantity,\n    unit: selection.unit,\n    unit_price: pricing.unit_price,\n    subtotal: selection.quantity * pricing.unit_price,\n    supplier_id: pricing.supplier_id,\n    currency: pricing.currency || 'BRL'\n  };\n\n  cart.items.push(cartItem);\n  console.log('â• [Cart] Added item:', product.product_name);\n}\n\n// ===== CALCULATE TOTALS =====\ncart.subtotal = cart.items.reduce((sum, item) => sum + item.subtotal, 0);\ncart.tax = 0; // Calculate if needed\ncart.delivery_fee = 0; // Calculate based on supplier or location\ncart.total = cart.subtotal + cart.tax + cart.delivery_fee;\ncart.updated_at = new Date().toISOString();\n\n// ===== SAVE CART TO SESSION =====\nawait $supabase\n  .from('line_sessions')\n  .update({\n    preferences_captured: { cart },\n    last_activity_at: new Date().toISOString(),\n    message_count: $supabase.sql`message_count + 1`,\n    user_messages: $supabase.sql`user_messages + 1`\n  })\n  .eq('session_id', sessionId);\n\nconsole.log('ğŸ’¾ [Cart] Saved. Total items:', cart.items.length, 'Total:', cart.total);\n\n// ===== RETURN CART SUMMARY =====\nconst message = `âœ… *Adicionado ao carrinho!*\\n\\n` +\n  `${selection.quantity} ${selection.unit} de *${product.product_name}*\\n` +\n  `R$ ${pricing.unit_price.toFixed(2)} cada\\n\\n` +\n  `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n  `ğŸ›’ *SEU CARRINHO* (${cart.items.length} ${cart.items.length === 1 ? 'item' : 'itens'})\\n\\n` +\n  cart.items.map((item, i) =>\n    `${i + 1}. *${item.product_name}*\\n` +\n    `   ${item.quantity} ${item.unit} x R$ ${item.unit_price.toFixed(2)} = R$ ${item.subtotal.toFixed(2)}`\n  ).join('\\n\\n') +\n  `\\n\\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n  `Subtotal: R$ ${cart.subtotal.toFixed(2)}\\n` +\n  `Entrega: R$ ${cart.delivery_fee.toFixed(2)}\\n` +\n  `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n  `*TOTAL: R$ ${cart.total.toFixed(2)}*\\n\\n` +\n  `O que deseja fazer?\\n\\n` +\n  `1ï¸âƒ£ Adicionar mais produtos (busque novamente)\\n` +\n  `2ï¸âƒ£ *\"confirmar\"* para finalizar pedido\\n` +\n  `3ï¸âƒ£ *\"limpar\"* para cancelar`;\n\nreturn JSON.stringify({\n  status: 'item_added',\n  cart,\n  message\n});\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1040,
        928
      ],
      "id": "tool-build-cart",
      "name": "build_shopping_cart"
    },
    {
      "parameters": {
        "description": "Finaliza pedido criando purchase_order e purchase_order_items do carrinho. Limpa sessÃ£o ao completar. Rollback automÃ¡tico em caso de erro.",
        "jsCode": "// ===== EXECUTE CHECKOUT - COMPLETE IMPLEMENTATION =====\n// Tool for n8n workflow: creates purchase_order and purchase_order_items from cart in session\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\n\nconsole.log('ğŸ’³ [Checkout] User:', userData.phone_number);\n\n// ===== VALIDATE USER =====\nif (!userData.restaurant_id || !userData.person_id) {\n  console.error('âŒ [Checkout] User data incomplete');\n  return JSON.stringify({\n    success: false,\n    error: true,\n    message: 'âš ï¸ Erro: dados de usuÃ¡rio incompletos. Por favor, faÃ§a login novamente.'\n  });\n}\n\n// ===== GET CART FROM SESSION =====\nlet cart = null;\nlet sessionId = null;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n\n  // Check if this is a shopping session with a cart\n  if (session.primary_intent === 'compra' && session.preferences_captured?.cart) {\n    cart = session.preferences_captured.cart;\n    sessionId = session.session_id;\n\n    // Check if cart is marked ready for checkout\n    const isReady = session.preferences_captured?.ready_for_checkout;\n\n    console.log('ğŸ›’ [Checkout] Cart found:', cart.cart_id, 'Items:', cart.items?.length || 0);\n    console.log('âœ… [Checkout] Ready for checkout:', isReady);\n\n    // Optional: enforce ready_for_checkout flag\n    // if (!isReady) {\n    //   return JSON.stringify({\n    //     success: false,\n    //     message: 'Carrinho nÃ£o confirmado. Digite \"confirmar\" para finalizar.'\n    //   });\n    // }\n  }\n}\n\n// ===== VALIDATE CART EXISTS AND HAS ITEMS =====\nif (!cart || !cart.items || cart.items.length === 0) {\n  console.error('âŒ [Checkout] No cart or empty cart');\n  return JSON.stringify({\n    success: false,\n    error: true,\n    message: 'ğŸ›’ Carrinho vazio!\\n\\n' +\n      'Adicione produtos ao carrinho antes de finalizar.\\n\\n' +\n      'Digite \"buscar produtos\" para comeÃ§ar.'\n  });\n}\n\nconsole.log(`ğŸ’° [Checkout] Cart total: ${cart.total} (${cart.items.length} items)`);\n\n// ===== CREATE PURCHASE ORDER =====\ntry {\n  const orderData = {\n    restaurant_id: userData.restaurant_id,\n    ordered_by_person_id: userData.person_id,\n    session_id: sessionId,\n    order_status: 'pending', // ENUM: pending, confirmed, preparing, shipped, delivered, cancelled\n    payment_status: 'pending', // ENUM: pending, paid, failed, refunded\n    order_date: new Date().toISOString(),\n    total_amount: cart.total,\n    subtotal: cart.subtotal,\n    tax: cart.tax || 0,\n    delivery_fee: cart.delivery_fee || 0,\n    currency: cart.currency || 'BRL',\n    order_notes: `Created from cart: ${cart.cart_id}`\n    // delivery_date would be calculated based on supplier lead times\n    // expected_delivery_date: null (can be added later)\n  };\n\n  console.log('ğŸ“ [Checkout] Creating purchase order...');\n\n  const { data: order, error: orderError } = await $supabase\n    .from('purchase_orders')\n    .insert(orderData)\n    .select('*')\n    .single();\n\n  if (orderError) {\n    console.error('âŒ [Checkout] Error creating order:', orderError);\n    return JSON.stringify({\n      success: false,\n      error: true,\n      message: 'âš ï¸ Erro ao criar pedido. Tente novamente.\\n\\n' +\n        'Se o problema persistir, contate suporte.'\n    });\n  }\n\n  console.log('âœ… [Checkout] Purchase order created:', order.id);\n\n  // ===== CREATE PURCHASE ORDER ITEMS =====\n  const orderItems = cart.items.map(item => ({\n    order_id: order.id,\n    master_list_id: item.master_list_id,\n    product_name: item.product_name, // Denormalized for history\n    quantity: item.quantity,\n    unit: item.unit,\n    unit_price: item.unit_price,\n    subtotal: item.subtotal,\n    supplier_id: item.supplier_id,\n    currency: item.currency || 'BRL',\n    // Optional fields:\n    // brand: item.brand,\n    // sku: item.sku,\n    // item_notes: item.notes\n  }));\n\n  console.log('ğŸ“¦ [Checkout] Creating order items:', orderItems.length);\n\n  const { data: items, error: itemsError } = await $supabase\n    .from('purchase_order_items')\n    .insert(orderItems)\n    .select('*');\n\n  if (itemsError) {\n    console.error('âŒ [Checkout] Error creating order items:', itemsError);\n\n    // Rollback: Delete the order since items failed\n    await $supabase\n      .from('purchase_orders')\n      .delete()\n      .eq('id', order.id);\n\n    console.log('ğŸ”„ [Checkout] Rolled back order:', order.id);\n\n    return JSON.stringify({\n      success: false,\n      error: true,\n      message: 'âš ï¸ Erro ao processar items do pedido.\\n\\n' +\n        'Por favor, tente novamente.'\n    });\n  }\n\n  console.log('âœ… [Checkout] Order items created:', items?.length || 0);\n\n  // ===== MARK SESSION AS COMPLETED =====\n  await $supabase\n    .from('line_sessions')\n    .update({\n      awaiting_continuation: false,\n      session_end: new Date().toISOString(),\n      session_notes: `Order created: ${order.id}`,\n      preferences_captured: {\n        ...userData.active_session.preferences_captured,\n        cart: null, // Clear cart\n        order_id: order.id,\n        order_completed_at: new Date().toISOString()\n      }\n    })\n    .eq('session_id', sessionId);\n\n  console.log('ğŸ [Checkout] Session completed:', sessionId);\n\n  // ===== PREPARE CONFIRMATION MESSAGE =====\n  const orderNumber = order.id || 'ORD-' + Date.now();\n\n  // Calculate estimated delivery (2-3 days)\n  const deliveryDate = new Date();\n  deliveryDate.setDate(deliveryDate.getDate() + 2);\n\n  // Build items summary\n  const itemsSummary = cart.items.map((item, i) =>\n    `${i + 1}. *${item.product_name}*\\n` +\n    `   ${item.quantity} ${item.unit} x R$ ${item.unit_price.toFixed(2)} = R$ ${item.subtotal.toFixed(2)}`\n  ).join('\\n\\n');\n\n  const message = `âœ… *PEDIDO CONFIRMADO!*\\n\\n` +\n    `ğŸ“‹ NÃºmero: *#${orderNumber}*\\n` +\n    `ğŸ“… Data: ${new Date().toLocaleDateString('pt-BR')}\\n` +\n    `ğŸšš Entrega estimada: ${deliveryDate.toLocaleDateString('pt-BR')}\\n\\n` +\n    `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n    `ğŸ“¦ *ITENS DO PEDIDO* (${cart.items.length})\\n\\n` +\n    `${itemsSummary}\\n\\n` +\n    `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n    `Subtotal: R$ ${cart.subtotal.toFixed(2)}\\n` +\n    (cart.tax > 0 ? `Impostos: R$ ${cart.tax.toFixed(2)}\\n` : '') +\n    (cart.delivery_fee > 0 ? `Entrega: R$ ${cart.delivery_fee.toFixed(2)}\\n` : 'Entrega: GRÃTIS\\n') +\n    `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n    `ğŸ’° *TOTAL: R$ ${cart.total.toFixed(2)}*\\n\\n` +\n    `ğŸ“¦ Status: ${translateStatus(order.order_status)}\\n` +\n    `ğŸ’³ Pagamento: ${translatePaymentStatus(order.payment_status)}\\n\\n` +\n    `ğŸ‰ Seu pedido estÃ¡ confirmado!\\n` +\n    `Avisaremos quando houver atualizaÃ§Ãµes.\\n\\n` +\n    `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n    `ğŸ’¬ Precisa de algo mais?\\n` +\n    `Digite \"menu\" para ver opÃ§Ãµes.`;\n\n  return JSON.stringify({\n    success: true,\n    order: {\n      id: order.id,\n      order_number: orderNumber,\n      total: cart.total,\n      items_count: cart.items.length,\n      status: order.order_status,\n      payment_status: order.payment_status,\n      order_date: order.order_date,\n      estimated_delivery: deliveryDate.toISOString()\n    },\n    message: message\n  });\n\n} catch (error) {\n  console.error('âŒ [Checkout] Unexpected error:', error);\n  return JSON.stringify({\n    success: false,\n    error: true,\n    message: 'âš ï¸ Erro ao processar pedido.\\n\\n' +\n      'Por favor, tente novamente.\\n' +\n      'Se o problema persistir, contate suporte.'\n  });\n}\n\n// ===== HELPER FUNCTIONS =====\nfunction translateStatus(status) {\n  const statusMap = {\n    'pending': 'Pendente',\n    'confirmed': 'Confirmado',\n    'preparing': 'Em PreparaÃ§Ã£o',\n    'shipped': 'Enviado',\n    'delivered': 'Entregue',\n    'cancelled': 'Cancelado'\n  };\n  return statusMap[status] || status;\n}\n\nfunction translatePaymentStatus(status) {\n  const statusMap = {\n    'pending': 'Pendente',\n    'paid': 'Pago',\n    'failed': 'Falhou',\n    'refunded': 'Reembolsado'\n  };\n  return statusMap[status] || status;\n}\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -912,
        928
      ],
      "id": "tool-execute-checkout",
      "name": "execute_checkout"
    },
    {
      "parameters": {
        "description": "Mostra o menu principal de opÃ§Ãµes para restaurantes.",
        "jsCode": "// ===== SHOW CUSTOMER MENU =====\nconst menu = `ğŸ½ï¸ *MENU PRINCIPAL - RESTAURANTE*\\n\\n` +\n  `O que quer fazer hoje?\\n\\n` +\n  `1ï¸âƒ£ ğŸ›’ *Fazer uma compra*\\n` +\n  `   Buscar produtos e criar pedido\\n\\n` +\n  `2ï¸âƒ£ âš™ï¸ *Configurar preferÃªncias*\\n` +\n  `   Definir marcas, formatos, restriÃ§Ãµes\\n\\n` +\n  `3ï¸âƒ£ ğŸ“¦ *Ver meus pedidos*\\n` +\n  `   Consultar estado e histÃ³rico\\n\\n` +\n  `4ï¸âƒ£ ğŸª *Gestionar fornecedores*\\n` +\n  `   Adicionar ou atualizar suppliers\\n\\n` +\n  `Digite o nÃºmero ou descreva o que precisa.`;\n\nreturn JSON.stringify({\n  menu: menu,\n  options: ['comprar', 'configurar', 'pedidos', 'fornecedores']\n});",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -784,
        928
      ],
      "id": "tool-customer-menu",
      "name": "show_customer_menu"
    },
    {
      "parameters": {
        "description": "Inicia o registro de novo fornecedor. Valida company_name Ãºnico, cria registro en suppliers con contact_method enum, business_type enum.",
        "jsCode": "// ===== ONBOARDING SUPPLIER WITH VALIDATIONS =====\nconst input = $input.first().json;\n\n// VALIDATION: business_type enum\nconst validBusinessTypes = ['wholesaler', 'distributor', 'manufacturer', 'local_producer'];\n\n// VALIDATION: contact_method enum  \nconst validContactMethods = ['email', 'whatsapp', 'phone', 'website', 'portal', 'fax', 'in_person'];\n\nconst response = {\n  status: 'collecting_data',\n  step: 1,\n  total_steps: 4,\n  fields_collected: [],\n  fields_pending: ['company_name', 'contact_name', 'coverage_area', 'business_type'],\n  valid_business_types: validBusinessTypes,\n  valid_contact_methods: validContactMethods,\n  message: 'ğŸ“‹ *Registro de Fornecedor*\\n\\n' +\n    'Bem-vindo! Para registrar-se como fornecedor no Frepi, preciso de alguns dados.\\n\\n' +\n    '*Qual Ã© a razÃ£o social da sua empresa?*',\n  next_action: 'await_company_name',\n  db_table: 'suppliers',\n  unique_fields: ['company_name']\n};\n\nreturn JSON.stringify(response);",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1296,
        1472
      ],
      "id": "tool-onboarding-supplier",
      "name": "onboarding_supplier"
    },
    {
      "parameters": {
        "description": "Processa lista de preÃ§os do supplier com parsing flexible (|, ,, -). Valida formato, produto, preÃ§o, unidade. Guarda em line_sessions para normalizaÃ§Ã£o.",
        "jsCode": "// ===== UPLOAD SUPPLIER PRICES - COMPLETE IMPLEMENTATION =====\n// Tool for n8n workflow: parses and validates supplier price lists\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\nconst userMessage = (input.query || input.message || '').trim();\n\nconsole.log('ğŸ’° [Upload] Supplier:', userData.phone_number, 'Message length:', userMessage.length);\n\n// ===== CHECK IF USER IS SUPPLIER =====\nif (userData.is_new_user || !userData.supplier_id) {\n  console.log('âŒ [Upload] Not a supplier');\n  return JSON.stringify({\n    error: true,\n    message: 'VocÃª precisa estar cadastrado como fornecedor. ğŸ˜Š\\n\\nDigite \"registrar\" para comeÃ§ar.'\n  });\n}\n\n// ===== CONSTANTS =====\nconst TIMEOUT_MINUTES = 30;\nconst VALID_UNITS = ['kg', 'g', 'l', 'ml', 'caixa', 'unidade', 'pacote', 'fardo', 'saco'];\nconst VALID_CURRENCIES = ['BRL', 'USD', 'EUR'];\n\n// ===== HELPER FUNCTIONS =====\nfunction parsePriceList(text) {\n  // Parse formats:\n  // \"Tomate 500g | 4.50 | caixa\"\n  // \"Tomate 500g, 4.50, caixa\"\n  // \"Tomate 500g - R$ 4.50 - caixa\"\n\n  const lines = text.split('\\n').map(l => l.trim()).filter(l => l.length > 0);\n  const products = [];\n  const errors = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const lineNum = i + 1;\n    const line = lines[i];\n\n    // Try different separators\n    let parts = null;\n    if (line.includes('|')) {\n      parts = line.split('|').map(p => p.trim());\n    } else if (line.includes(',')) {\n      parts = line.split(',').map(p => p.trim());\n    } else if (line.includes('-')) {\n      parts = line.split('-').map(p => p.trim());\n    }\n\n    if (!parts || parts.length < 3) {\n      errors.push({\n        line: lineNum,\n        content: line,\n        error: 'Formato invÃ¡lido. Use: Produto | PreÃ§o | Unidade'\n      });\n      continue;\n    }\n\n    // Extract parts\n    const productName = parts[0].trim();\n    let priceStr = parts[1].trim().replace('R$', '').replace(',', '.').trim();\n    const unit = parts[2].trim().toLowerCase();\n\n    // Optional fields\n    const sku = parts[3] ? parts[3].trim() : null;\n    const brand = parts[4] ? parts[4].trim() : null;\n\n    // Validate product name\n    if (productName.length < 3) {\n      errors.push({\n        line: lineNum,\n        content: line,\n        error: 'Nome de produto muito curto (mÃ­nimo 3 caracteres)'\n      });\n      continue;\n    }\n\n    // Validate price\n    const price = parseFloat(priceStr);\n    if (isNaN(price) || price <= 0) {\n      errors.push({\n        line: lineNum,\n        content: line,\n        error: `PreÃ§o invÃ¡lido: \"${priceStr}\". Deve ser nÃºmero > 0`\n      });\n      continue;\n    }\n\n    // Validate unit\n    if (!VALID_UNITS.includes(unit)) {\n      errors.push({\n        line: lineNum,\n        content: line,\n        error: `Unidade invÃ¡lida: \"${unit}\". Use: ${VALID_UNITS.join(', ')}`\n      });\n      continue;\n    }\n\n    // Add product\n    products.push({\n      product_name: productName,\n      unit_price: price,\n      unit: unit,\n      sku: sku,\n      brand: brand,\n      currency: 'BRL'\n    });\n  }\n\n  return { products, errors };\n}\n\n// ===== CHECK FOR EXISTING SESSION =====\nlet sessionData = null;\nlet sessionId = null;\nlet isNewSession = true;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n  if (session.primary_intent === 'upload_prices' && session.awaiting_continuation) {\n    // Check timeout\n    const sessionAge = Date.now() - new Date(session.last_activity_at).getTime();\n    const timeoutMs = TIMEOUT_MINUTES * 60 * 1000;\n\n    if (sessionAge > timeoutMs) {\n      console.log('â±ï¸ [Upload] Session timeout');\n      await $supabase\n        .from('line_sessions')\n        .update({\n          awaiting_continuation: false,\n          session_notes: `Timeout: ${TIMEOUT_MINUTES} minutos`\n        })\n        .eq('session_id', session.session_id);\n    } else {\n      sessionData = session.preferences_captured || {};\n      sessionId = session.session_id;\n      isNewSession = false;\n      console.log('ğŸ”„ [Upload] Continuing session:', sessionId);\n    }\n  }\n}\n\n// ===== HANDLE CANCELLATION =====\nif (userMessage.toLowerCase().match(/cancelar|desistir|parar/)) {\n  if (sessionId) {\n    await $supabase\n      .from('line_sessions')\n      .update({\n        session_goal_achieved: false,\n        awaiting_continuation: false,\n        session_end: new Date().toISOString(),\n        session_notes: 'Cancelado pelo usuÃ¡rio'\n      })\n      .eq('session_id', sessionId);\n  }\n\n  return JSON.stringify({\n    status: 'cancelled',\n    message: 'Upload cancelado. âŒ\\n\\nDigite \"menu\" para ver opÃ§Ãµes.'\n  });\n}\n\n// ===== CREATE NEW SESSION IF NEEDED =====\nif (!sessionData) {\n  sessionId = `${userData.phone_number}_upload_${Date.now()}`;\n  sessionData = {\n    upload_status: 'awaiting_list',\n    supplier_id: userData.supplier_id,\n    started_at: new Date().toISOString()\n  };\n\n  console.log('ğŸ†• [Upload] Creating new session:', sessionId);\n\n  const { error: sessionError } = await $supabase\n    .from('line_sessions')\n    .insert({\n      session_id: sessionId,\n      supplier_id: userData.supplier_id,\n      person_id: userData.person_id,\n      channel_type: 'whatsapp',\n      channel_id: userData.phone_number,\n      session_type: 'data_upload',\n      primary_intent: 'upload_prices',\n      awaiting_continuation: true,\n      message_count: 1,\n      user_messages: 1,\n      preferences_captured: sessionData\n    });\n\n  if (sessionError) {\n    console.error('âŒ [Upload] Error creating session:', sessionError);\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ Erro ao iniciar upload. Tente novamente.'\n    });\n  }\n\n  isNewSession = true;\n}\n\n// Update session activity\nawait $supabase\n  .from('line_sessions')\n  .update({\n    last_activity_at: new Date().toISOString(),\n    message_count: $supabase.sql`message_count + 1`,\n    user_messages: $supabase.sql`user_messages + 1`\n  })\n  .eq('session_id', sessionId);\n\n// ===== SHOW WELCOME MESSAGE IF NEW SESSION =====\nif (isNewSession) {\n  return JSON.stringify({\n    status: 'awaiting_file',\n    session_id: sessionId,\n    accepted_formats: ['text'],\n    message: 'ğŸ’° *Enviar Lista de PreÃ§os*\\n\\n' +\n      'Envie sua lista de produtos no formato:\\n\\n' +\n      'ğŸ“ *Formato:*\\n' +\n      'Produto | PreÃ§o | Unidade\\n\\n' +\n      'ğŸ“‹ *Exemplo:*\\n' +\n      'Tomate 500g | 4.50 | caixa\\n' +\n      'Cebola 1kg | 3.20 | kg\\n' +\n      'Arroz Integral 1kg | 5.50 | pacote\\n\\n' +\n      'âš™ï¸ *Unidades vÃ¡lidas:*\\n' +\n      `${VALID_UNITS.join(', ')}\\n\\n` +\n      'ğŸ’¡ *Dica:*\\n' +\n      'â€¢ Separe com | ou , ou -\\n' +\n      'â€¢ PreÃ§o sem R$ (sÃ³ nÃºmeros)\\n' +\n      'â€¢ Uma linha por produto\\n\\n' +\n      'Cole sua lista e envie!'\n  });\n}\n\n// ===== PARSE PRICE LIST =====\nconsole.log('ğŸ“ [Upload] Parsing price list...');\nconst { products, errors } = parsePriceList(userMessage);\n\nconsole.log(`âœ… [Upload] Parsed: ${products.length} products, ${errors.length} errors`);\n\n// ===== HANDLE ERRORS =====\nif (errors.length > 0 && products.length === 0) {\n  // All lines failed\n  const errorMsg = errors.slice(0, 5).map(e =>\n    `Linha ${e.line}: ${e.error}`\n  ).join('\\n');\n\n  return JSON.stringify({\n    status: 'parse_error',\n    errors: errors,\n    message: 'âŒ *Erro ao processar lista*\\n\\n' +\n      errorMsg +\n      (errors.length > 5 ? `\\n\\n...e mais ${errors.length - 5} erros` : '') +\n      '\\n\\nğŸ“ *Formato correto:*\\n' +\n      'Produto | PreÃ§o | Unidade\\n\\n' +\n      'Exemplo:\\n' +\n      'Tomate 500g | 4.50 | caixa'\n  });\n}\n\n// ===== SAVE TO SESSION =====\nsessionData.upload_status = 'list_received';\nsessionData.price_list = products;\nsessionData.parse_errors = errors;\nsessionData.total_products = products.length;\nsessionData.total_errors = errors.length;\nsessionData.uploaded_at = new Date().toISOString();\n\nawait $supabase\n  .from('line_sessions')\n  .update({\n    preferences_captured: sessionData\n  })\n  .eq('session_id', sessionId);\n\nconsole.log('ğŸ’¾ [Upload] Saved to session:', sessionId);\n\n// ===== PREPARE SUCCESS MESSAGE =====\nconst totalValue = products.reduce((sum, p) => sum + p.unit_price, 0);\n\n// Group by unit for summary\nconst unitSummary = {};\nproducts.forEach(p => {\n  if (!unitSummary[p.unit]) {\n    unitSummary[p.unit] = 0;\n  }\n  unitSummary[p.unit]++;\n});\n\nconst unitBreakdown = Object.entries(unitSummary)\n  .map(([unit, count]) => `â€¢ ${count} em ${unit}`)\n  .join('\\n');\n\nconst errorWarning = errors.length > 0\n  ? `\\n\\nâš ï¸ *${errors.length} linha(s) com erro* (ignoradas):\\n` +\n    errors.slice(0, 3).map(e => `â€¢ Linha ${e.line}: ${e.error}`).join('\\n') +\n    (errors.length > 3 ? `\\nâ€¢ ...e mais ${errors.length - 3}` : '')\n  : '';\n\nconst sampleProducts = products.slice(0, 5).map((p, i) =>\n  `${i + 1}. ${p.product_name} - R$ ${p.unit_price.toFixed(2)}/${p.unit}`\n).join('\\n');\n\nconst message = 'âœ… *LISTA RECEBIDA!*\\n\\n' +\n  `ğŸ“¦ *${products.length} produtos* processados\\n` +\n  `ğŸ’° Valor mÃ©dio: R$ ${(totalValue / products.length).toFixed(2)}\\n\\n` +\n  '*DistribuiÃ§Ã£o por unidade:*\\n' +\n  unitBreakdown +\n  errorWarning +\n  '\\n\\n*Primeiros produtos:*\\n' +\n  sampleProducts +\n  (products.length > 5 ? `\\n...e mais ${products.length - 5} produtos` : '') +\n  '\\n\\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n' +\n  'ğŸ”„ *PrÃ³ximo passo:*\\n' +\n  'O agente vai normalizar os produtos mapeando ao catÃ¡logo.\\n\\n' +\n  'Aguarde...';\n\nreturn JSON.stringify({\n  status: 'success',\n  session_id: sessionId,\n  products_count: products.length,\n  errors_count: errors.length,\n  total_value: totalValue,\n  unit_summary: unitSummary,\n  products: products,\n  next_action: 'normalize_product_list',\n  message: message\n});\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1168,
        1472
      ],
      "id": "tool-upload-prices",
      "name": "upload_supplier_prices"
    },
    {
      "parameters": {
        "description": "Normaliza produtos mapeando a master_list via vector search. Classifica por confianÃ§a, detecta produtos novos, alerta preÃ§os anÃ´malos (>50%).",
        "jsCode": "// ===== NORMALIZE PRODUCT LIST - COMPLETE IMPLEMENTATION =====\n// Tool for n8n workflow: maps supplier products to master_list using vector search\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\n\nconsole.log('ğŸ”§ [Normalize] Supplier:', userData.phone_number);\n\n// ===== CHECK IF USER IS SUPPLIER =====\nif (userData.is_new_user || !userData.supplier_id) {\n  console.log('âŒ [Normalize] Not a supplier');\n  return JSON.stringify({\n    error: true,\n    message: 'VocÃª precisa estar cadastrado como fornecedor.'\n  });\n}\n\n// ===== GET PRICE LIST FROM SESSION =====\nlet priceList = null;\nlet sessionId = null;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n  if (session.primary_intent === 'upload_prices' && session.preferences_captured?.price_list) {\n    priceList = session.preferences_captured.price_list;\n    sessionId = session.session_id;\n    console.log('ğŸ“‹ [Normalize] Found price list:', priceList.length, 'products');\n  }\n}\n\nif (!priceList || priceList.length === 0) {\n  console.log('âŒ [Normalize] No price list found');\n  return JSON.stringify({\n    error: true,\n    message: 'âš ï¸ Nenhuma lista de preÃ§os encontrada.\\n\\nEnvie primeiro sua lista usando \"enviar preÃ§os\".'\n  });\n}\n\nconsole.log(`ğŸ”„ [Normalize] Normalizing ${priceList.length} products...`);\n\n// ===== NORMALIZE PRODUCTS =====\nconst mappedProducts = [];\nconst warnings = [];\nlet highConfidence = 0;\nlet mediumConfidence = 0;\nlet newProducts = 0;\n\nfor (const item of priceList) {\n  try {\n    // Generate embedding for product name\n    console.log(`ğŸ” [Normalize] Searching: ${item.product_name}`);\n\n    const embeddingResponse = await $http.request({\n      method: 'POST',\n      url: 'https://api.openai.com/v1/embeddings',\n      headers: {\n        'Authorization': `Bearer ${$credentials.openAiApi.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: {\n        model: 'text-embedding-ada-002',\n        input: item.product_name\n      }\n    });\n\n    if (embeddingResponse.statusCode !== 200) {\n      console.error('âŒ [Normalize] Embedding failed for:', item.product_name);\n      warnings.push({\n        product: item.product_name,\n        issue: 'Embedding generation failed',\n        action: 'skip'\n      });\n      continue;\n    }\n\n    const queryEmbedding = embeddingResponse.data.data[0].embedding;\n\n    // Search master_list using vector similarity\n    const { data: matches, error: searchError } = await $supabase.rpc('match_products_v2', {\n      query_embedding: queryEmbedding,\n      match_threshold: 0.7,\n      match_count: 1\n    });\n\n    let masterListId = null;\n    let similarity = 0;\n    let confidence = 'new';\n\n    if (!searchError && matches && matches.length > 0) {\n      const bestMatch = matches[0];\n      masterListId = bestMatch.id;\n      similarity = bestMatch.similarity || 0;\n\n      // Classify confidence\n      if (similarity >= 0.9) {\n        confidence = 'high';\n        highConfidence++;\n      } else if (similarity >= 0.7) {\n        confidence = 'medium';\n        mediumConfidence++;\n      } else {\n        confidence = 'low';\n        newProducts++;\n      }\n\n      console.log(`âœ… [Normalize] Matched: ${item.product_name} â†’ ${bestMatch.product_name} (${(similarity * 100).toFixed(0)}%)`);\n    } else {\n      // No match found - treat as new product\n      newProducts++;\n      console.log(`ğŸ†• [Normalize] New product: ${item.product_name}`);\n    }\n\n    // Check for price outliers if matched\n    if (masterListId) {\n      const { data: priceHistory } = await $supabase\n        .from('pricing_history')\n        .select('unit_price')\n        .eq('master_list_id', masterListId)\n        .order('effective_date', { ascending: false })\n        .limit(10);\n\n      if (priceHistory && priceHistory.length > 0) {\n        const avgPrice = priceHistory.reduce((sum, p) => sum + parseFloat(p.unit_price), 0) / priceHistory.length;\n        const priceChange = Math.abs((item.unit_price - avgPrice) / avgPrice);\n\n        if (priceChange > 0.5) {\n          // Price changed more than 50%\n          warnings.push({\n            product: item.product_name,\n            issue: `PreÃ§o ${priceChange > 0 ? 'maior' : 'menor'} que mÃ©dia`,\n            current_price: item.unit_price,\n            market_avg: avgPrice.toFixed(2),\n            change_percent: (priceChange * 100).toFixed(0),\n            action: 'review_recommended'\n          });\n        }\n      }\n    }\n\n    // Add to mapped products\n    mappedProducts.push({\n      supplier_product_name: item.product_name,\n      master_list_id: masterListId,\n      unit_price: item.unit_price,\n      unit: item.unit,\n      sku: item.sku,\n      brand: item.brand,\n      currency: item.currency || 'BRL',\n      mapping_confidence: similarity,\n      confidence_level: confidence,\n      is_new: masterListId === null\n    });\n\n  } catch (error) {\n    console.error('âŒ [Normalize] Error processing:', item.product_name, error);\n    warnings.push({\n      product: item.product_name,\n      issue: 'Processing error: ' + error.message,\n      action: 'skip'\n    });\n  }\n}\n\nconsole.log(`âœ… [Normalize] Completed: ${mappedProducts.length} products normalized`);\nconsole.log(`   High confidence: ${highConfidence}, Medium: ${mediumConfidence}, New: ${newProducts}`);\n\n// ===== SAVE TO SESSION =====\nconst normalizationData = {\n  normalized_at: new Date().toISOString(),\n  mapped_products: mappedProducts,\n  warnings: warnings,\n  stats: {\n    total_products: mappedProducts.length,\n    high_confidence: highConfidence,\n    medium_confidence: mediumConfidence,\n    new_products: newProducts,\n    warnings_count: warnings.length\n  }\n};\n\nawait $supabase\n  .from('line_sessions')\n  .update({\n    preferences_captured: {\n      ...userData.active_session.preferences_captured,\n      normalization: normalizationData\n    },\n    last_activity_at: new Date().toISOString()\n  })\n  .eq('session_id', sessionId);\n\nconsole.log('ğŸ’¾ [Normalize] Saved to session');\n\n// ===== CALCULATE TOTALS =====\nconst totalValue = mappedProducts.reduce((sum, p) => sum + p.unit_price, 0);\n\n// Group by category (if we had category info)\nconst categorySummary = {};\nmappedProducts.forEach(p => {\n  const category = p.category || 'Outros';\n  if (!categorySummary[category]) {\n    categorySummary[category] = 0;\n  }\n  categorySummary[category]++;\n});\n\n// ===== PREPARE RESPONSE MESSAGE =====\nconst warningsList = warnings.length > 0\n  ? `\\n\\nâš ï¸ *${warnings.length} alerta(s):*\\n` +\n    warnings.slice(0, 3).map(w =>\n      `â€¢ ${w.product}: ${w.issue}` +\n      (w.current_price ? `\\n  Seu preÃ§o: R$ ${w.current_price.toFixed(2)} | MÃ©dia: R$ ${w.market_avg}` : '')\n    ).join('\\n') +\n    (warnings.length > 3 ? `\\nâ€¢ ...e mais ${warnings.length - 3} alertas` : '')\n  : '';\n\nconst confidenceBreakdown =\n  `ğŸ“Š *ConfianÃ§a do mapeamento:*\\n` +\n  `â€¢ Alta (>90%): ${highConfidence} produtos\\n` +\n  `â€¢ MÃ©dia (70-90%): ${mediumConfidence} produtos\\n` +\n  `â€¢ Novos no catÃ¡logo: ${newProducts} produtos`;\n\nconst message = 'ğŸ”§ *NORMALIZAÃ‡ÃƒO CONCLUÃDA!*\\n\\n' +\n  `âœ… ${mappedProducts.length} produtos processados\\n` +\n  `ğŸ’° Valor total: R$ ${totalValue.toFixed(2)}\\n\\n` +\n  confidenceBreakdown +\n  warningsList +\n  '\\n\\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n' +\n  'ğŸ”„ *PrÃ³ximo passo:*\\n' +\n  'Deseja publicar estes preÃ§os no catÃ¡logo?\\n\\n' +\n  'â€¢ *\"publicar\"* - Publicar agora\\n' +\n  'â€¢ *\"revisar\"* - Ver detalhes dos alertas\\n' +\n  'â€¢ *\"cancelar\"* - Descartar esta lista';\n\nreturn JSON.stringify({\n  status: 'normalized',\n  session_id: sessionId,\n  products_mapped: mappedProducts.length,\n  high_confidence: highConfidence,\n  medium_confidence: mediumConfidence,\n  new_products: newProducts,\n  warnings_count: warnings.length,\n  total_value: totalValue,\n  next_action: 'await_publish_confirmation',\n  message: message\n});\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1040,
        1472
      ],
      "id": "tool-normalize-list",
      "name": "normalize_product_list"
    },
    {
      "parameters": {
        "description": "Publica lista normalizada a pricing_history com verification_status=verified. Cria/atualiza supplier_mapped_products. Versionamento automÃ¡tico.",
        "jsCode": "// ===== PUBLISH TO CATALOG - COMPLETE IMPLEMENTATION =====\n// Tool for n8n workflow: publishes normalized products to pricing_history\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\nconst userMessage = (input.query || input.message || '').trim();\n\nconsole.log('ğŸ“¤ [Publish] Supplier:', userData.phone_number);\n\n// ===== CHECK IF USER IS SUPPLIER =====\nif (userData.is_new_user || !userData.supplier_id) {\n  console.log('âŒ [Publish] Not a supplier');\n  return JSON.stringify({\n    error: true,\n    message: 'VocÃª precisa estar cadastrado como fornecedor.'\n  });\n}\n\n// ===== GET NORMALIZED DATA FROM SESSION =====\nlet normalizationData = null;\nlet sessionId = null;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n  if (session.preferences_captured?.normalization) {\n    normalizationData = session.preferences_captured.normalization;\n    sessionId = session.session_id;\n    console.log('ğŸ“‹ [Publish] Found normalized data:', normalizationData.mapped_products?.length, 'products');\n  }\n}\n\nif (!normalizationData || !normalizationData.mapped_products || normalizationData.mapped_products.length === 0) {\n  console.log('âŒ [Publish] No normalized data found');\n  return JSON.stringify({\n    error: true,\n    message: 'âš ï¸ Nenhuma lista normalizada encontrada.\\n\\nPrimeiro envie e normalize sua lista de preÃ§os.'\n  });\n}\n\n// ===== CHECK FOR CONFIRMATION =====\nconst confirmed = userMessage.toLowerCase().match(/publicar|confirmar|sim|yes/);\n\nif (!confirmed) {\n  return JSON.stringify({\n    status: 'awaiting_confirmation',\n    message: 'â¸ï¸ PublicaÃ§Ã£o pausada.\\n\\nDigite *\"publicar\"* para confirmar ou *\"cancelar\"* para descartar.'\n  });\n}\n\nconsole.log(`ğŸ“¤ [Publish] Publishing ${normalizationData.mapped_products.length} products...`);\n\n// ===== PUBLISH TO PRICING_HISTORY =====\nconst effectiveDate = new Date().toISOString();\nconst version = 'v' + new Date().toISOString().split('T')[0].replace(/-/g, '');\n\nlet productsUpdated = 0;\nlet productsAdded = 0;\nconst errors = [];\n\ntry {\n  for (const product of normalizationData.mapped_products) {\n    try {\n      // Skip products that are new and not yet in master_list\n      if (product.is_new || !product.master_list_id) {\n        console.log(`â­ï¸ [Publish] Skipping new product: ${product.supplier_product_name}`);\n        productsAdded++;\n        // TODO: In future, create new master_list entries\n        continue;\n      }\n\n      // Insert into pricing_history\n      const pricingData = {\n        supplier_id: userData.supplier_id,\n        master_list_id: product.master_list_id,\n        unit_price: product.unit_price,\n        unit: product.unit,\n        currency: product.currency || 'BRL',\n        effective_date: effectiveDate,\n        verification_status: 'verified',\n        data_source: 'supplier_upload',\n        metadata: {\n          supplier_product_name: product.supplier_product_name,\n          sku: product.sku,\n          brand: product.brand,\n          mapping_confidence: product.mapping_confidence,\n          uploaded_via: 'whatsapp'\n        }\n      };\n\n      const { error: priceError } = await $supabase\n        .from('pricing_history')\n        .insert(pricingData);\n\n      if (priceError) {\n        console.error('âŒ [Publish] Error inserting price:', product.supplier_product_name, priceError);\n        errors.push({\n          product: product.supplier_product_name,\n          error: priceError.message\n        });\n        continue;\n      }\n\n      // Create/update supplier_mapped_products\n      const { data: existingMapping } = await $supabase\n        .from('supplier_mapped_products')\n        .select('id')\n        .eq('supplier_id', userData.supplier_id)\n        .eq('master_list_id', product.master_list_id)\n        .single();\n\n      if (existingMapping) {\n        // Update existing mapping\n        await $supabase\n          .from('supplier_mapped_products')\n          .update({\n            supplier_product_name: product.supplier_product_name,\n            supplier_sku: product.sku,\n            current_unit_price: product.unit_price,\n            mapping_confidence: product.mapping_confidence,\n            is_active: true,\n            last_price_update: effectiveDate,\n            updated_at: new Date().toISOString()\n          })\n          .eq('id', existingMapping.id);\n\n        productsUpdated++;\n      } else {\n        // Create new mapping\n        await $supabase\n          .from('supplier_mapped_products')\n          .insert({\n            supplier_id: userData.supplier_id,\n            master_list_id: product.master_list_id,\n            supplier_product_name: product.supplier_product_name,\n            supplier_sku: product.sku,\n            current_unit_price: product.unit_price,\n            mapping_confidence: product.mapping_confidence,\n            is_active: true,\n            last_price_update: effectiveDate\n          });\n\n        productsAdded++;\n      }\n\n      console.log(`âœ… [Publish] Published: ${product.supplier_product_name}`);\n\n    } catch (productError) {\n      console.error('âŒ [Publish] Error processing product:', product.supplier_product_name, productError);\n      errors.push({\n        product: product.supplier_product_name,\n        error: productError.message\n      });\n    }\n  }\n\n  console.log(`âœ… [Publish] Completed: ${productsUpdated} updated, ${productsAdded} added`);\n\n  // ===== MARK SESSION AS COMPLETED =====\n  await $supabase\n    .from('line_sessions')\n    .update({\n      session_goal_achieved: true,\n      awaiting_continuation: false,\n      session_end: new Date().toISOString(),\n      conversion_occurred: true,\n      session_notes: `Published ${productsUpdated + productsAdded} products`,\n      preferences_captured: {\n        ...userData.active_session.preferences_captured,\n        published_at: new Date().toISOString(),\n        publication_version: version,\n        products_published: productsUpdated + productsAdded\n      }\n    })\n    .eq('session_id', sessionId);\n\n  console.log('ğŸ [Publish] Session completed');\n\n  // ===== PREPARE SUCCESS MESSAGE =====\n  const errorSummary = errors.length > 0\n    ? `\\n\\nâš ï¸ ${errors.length} produto(s) com erro:\\n` +\n      errors.slice(0, 3).map(e => `â€¢ ${e.product}`).join('\\n') +\n      (errors.length > 3 ? `\\nâ€¢ ...e mais ${errors.length - 3}` : '')\n    : '';\n\n  const message = 'ğŸ“¤ *LISTA PUBLICADA COM SUCESSO!*\\n\\n' +\n    `âœ… VersÃ£o: *${version}*\\n` +\n    `ğŸ“… Data: ${new Date().toLocaleDateString('pt-BR')}\\n\\n` +\n    '*MudanÃ§as aplicadas:*\\n' +\n    `â€¢ ${productsUpdated} produtos atualizados\\n` +\n    `â€¢ ${productsAdded} produtos novos adicionados\\n` +\n    `â€¢ HistÃ³rico registrado em pricing_history\\n` +\n    errorSummary +\n    '\\n\\nğŸ‰ *Seus produtos jÃ¡ estÃ£o disponÃ­veis!*\\n' +\n    'Os restaurantes podem ver e fazer pedidos.\\n\\n' +\n    'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n' +\n    'ğŸ’¬ Precisa de algo mais?\\n' +\n    'Digite *\"menu\"* para ver opÃ§Ãµes.';\n\n  return JSON.stringify({\n    success: true,\n    version: version,\n    published_at: new Date().toISOString(),\n    products_updated: productsUpdated,\n    products_added: productsAdded,\n    errors_count: errors.length,\n    errors: errors,\n    message: message\n  });\n\n} catch (error) {\n  console.error('âŒ [Publish] Fatal error:', error);\n\n  // Mark session as failed\n  await $supabase\n    .from('line_sessions')\n    .update({\n      session_goal_achieved: false,\n      awaiting_continuation: false,\n      session_end: new Date().toISOString(),\n      session_notes: 'Error: ' + error.message\n    })\n    .eq('session_id', sessionId);\n\n  return JSON.stringify({\n    success: false,\n    error: true,\n    message: 'âš ï¸ Erro ao publicar lista.\\n\\n' +\n      'Por favor, tente novamente.\\n\\n' +\n      'Se o problema persistir, contate suporte.'\n  });\n}\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -912,
        1472
      ],
      "id": "tool-publish-catalog",
      "name": "publish_to_catalog"
    },
    {
      "parameters": {
        "description": "Mostra o menu principal de opÃ§Ãµes para fornecedores.",
        "jsCode": "// ===== SHOW SUPPLIER MENU =====\nconst menu = `ğŸª *MENU PRINCIPAL - FORNECEDOR*\\n\\n` +\n  `Que operaÃ§Ã£o quer realizar?\\n\\n` +\n  `1ï¸âƒ£ ğŸ’° *Enviar lista de preÃ§os*\\n` +\n  `   Atualizar produtos e preÃ§os\\n\\n` +\n  `2ï¸âƒ£ ğŸ“‹ *Ver catÃ¡logo ativo*\\n` +\n  `   Consultar produtos publicados\\n\\n` +\n  `3ï¸âƒ£ ğŸ“Š *HistÃ³rico de vendas*\\n` +\n  `   Ver pedidos recebidos\\n\\n` +\n  `4ï¸âƒ£ âš™ï¸ *Configurar perfil*\\n` +\n  `   Atualizar dados da empresa\\n\\n` +\n  `Digite o nÃºmero ou descreva o que precisa.`;\n\nreturn JSON.stringify({\n  menu: menu,\n  options: ['preÃ§os', 'catÃ¡logo', 'vendas', 'perfil']\n});",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -784,
        1472
      ],
      "id": "tool-supplier-menu",
      "name": "show_supplier_menu"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0.3,
          "timeout": 30000,
          "maxRetries": 3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1424,
        1200
      ],
      "id": "openai-customer-001",
      "name": "OpenAI Chat Customer",
      "credentials": {
        "openAiApi": {
          "id": "MdAepMtuPO5nFVI0",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0.2,
          "timeout": 30000,
          "maxRetries": 3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1424,
        1456
      ],
      "id": "openai-supplier-001",
      "name": "OpenAI Chat Supplier",
      "credentials": {
        "openAiApi": {
          "id": "MdAepMtuPO5nFVI0",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Extract Message Data').first().json.session_id }}",
        "contextWindowLength": 30
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -1296,
        1200
      ],
      "id": "memory-customer-001",
      "name": "Memory Customer"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Extract Message Data').first().json.session_id }}",
        "contextWindowLength": 30
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -1296,
        1456
      ],
      "id": "memory-supplier-001",
      "name": "Memory Supplier"
    },
    {
      "parameters": {
        "operation": "send",
        "phoneNumberId": "={{ $('WhatsApp Trigger').first().json.metadata.phone_number_id }}",
        "recipientPhoneNumber": "={{ $('Extract Message Data').first().json.phone_number }}",
        "textBody": "={{ $json.output || $json.message || 'Oi! Algo deu errado. Tente novamente! ğŸ˜Š' }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.whatsApp",
      "typeVersion": 1.1,
      "position": [
        -640,
        1200
      ],
      "id": "respond-whatsapp-001",
      "name": "Send WhatsApp Response",
      "credentials": {
        "whatsAppApi": {
          "id": "Jb7XPGihYb3LXtzN",
          "name": "Frepi Account"
        }
      }
    },
    {
      "id": "check_user_in_database_1763503554746",
      "name": "check_user_in_database",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1,
      "position": [
        800,
        300
      ],
      "parameters": {
        "name": "check_user_in_database",
        "description": "Verifica se um usuÃ¡rio existe na base de dados. Busca em parallel em restaurant_people e suppliers tables. Retorna TODA a informaÃ§Ã£o do usuÃ¡rio se existe (registered: true) ou indica novo usuÃ¡rio (registered: false).",
        "jsCode": "// ===================================================================\n// TOOL: check_user_in_database\n// ===================================================================\n// PURPOSE: Verifica si un usuario existe en la base de datos\n//          Busca en parallel en restaurant_people y suppliers\n//          Retorna TODA la informaciÃ³n del usuario si existe\n// ===================================================================\n\nconst input = $input.first().json;\nconst phoneNumber = input.phone_number || input.query || input.message;\n\nconsole.log('ğŸ” [Check User] Starting verification...');\nconsole.log('ğŸ“± [Check User] Phone number:', phoneNumber);\n\n// Validar que tenemos un phone number\nif (!phoneNumber) {\n  console.error('âŒ [Check User] No phone number provided');\n  return JSON.stringify({\n    success: false,\n    error: 'phone_number is required',\n    message: 'Por favor, proporciona un nÃºmero de telÃ©fono vÃ¡lido.'\n  });\n}\n\ntry {\n  // ===================================================================\n  // PASO 1: Buscar en restaurant_people con JOIN a restaurants\n  // ===================================================================\n\n  console.log('ğŸ” [Check User] Searching in restaurant_people...');\n\n  const { data: restaurantPerson, error: restaurantError } = await $supabase\n    .from('restaurant_people')\n    .select(`\n      id,\n      person_name,\n      role,\n      whatsapp_number,\n      is_active,\n      restaurant:restaurants (\n        id,\n        restaurant_name,\n        restaurant_type,\n        address,\n        city,\n        state,\n        postal_code,\n        category_preferences\n      )\n    `)\n    .eq('whatsapp_number', phoneNumber)\n    .eq('is_active', true)\n    .maybeSingle();\n\n  if (restaurantError && restaurantError.code !== 'PGRST116') {\n    console.error('âŒ [Check User] Error querying restaurant_people:', restaurantError);\n  }\n\n  // Si encontramos un restaurant person\n  if (restaurantPerson && restaurantPerson.restaurant) {\n    console.log('âœ… [Check User] User found as RESTAURANT PERSON');\n    console.log('   Person ID:', restaurantPerson.id);\n    console.log('   Restaurant ID:', restaurantPerson.restaurant.id);\n    console.log('   Name:', restaurantPerson.person_name);\n\n    return JSON.stringify({\n      success: true,\n      registered: true,\n      user_type: 'restaurant',\n\n      // IDs\n      restaurant_id: restaurantPerson.restaurant.id,\n      restaurant_person_id: restaurantPerson.id,\n      supplier_id: null,\n\n      // Contact info\n      phone_number: phoneNumber,\n\n      // Personal info\n      person_name: restaurantPerson.person_name,\n      role: restaurantPerson.role,\n\n      // Company info\n      company_name: restaurantPerson.restaurant.restaurant_name,\n      restaurant_type: restaurantPerson.restaurant.restaurant_type,\n\n      // Address\n      address: restaurantPerson.restaurant.address,\n      city: restaurantPerson.restaurant.city,\n      state: restaurantPerson.restaurant.state,\n      postal_code: restaurantPerson.restaurant.postal_code,\n\n      // Status\n      setup_complete: true,\n\n      // Preferences\n      preferences: restaurantPerson.restaurant.category_preferences || {},\n\n      message: `Bem-vindo de volta, ${restaurantPerson.person_name}! ğŸ‘‹`\n    });\n  }\n\n  // ===================================================================\n  // PASO 2: Buscar en suppliers\n  // ===================================================================\n\n  console.log('ğŸ” [Check User] Searching in suppliers...');\n\n  const { data: supplier, error: supplierError } = await $supabase\n    .from('suppliers')\n    .select('*')\n    .eq('phone_number', phoneNumber)\n    .eq('is_active', true)\n    .maybeSingle();\n\n  if (supplierError && supplierError.code !== 'PGRST116') {\n    console.error('âŒ [Check User] Error querying suppliers:', supplierError);\n  }\n\n  // Si encontramos un supplier\n  if (supplier) {\n    console.log('âœ… [Check User] User found as SUPPLIER');\n    console.log('   Supplier ID:', supplier.id);\n    console.log('   Company:', supplier.company_name);\n\n    return JSON.stringify({\n      success: true,\n      registered: true,\n      user_type: 'supplier',\n\n      // IDs\n      restaurant_id: null,\n      restaurant_person_id: null,\n      supplier_id: supplier.id,\n\n      // Contact info\n      phone_number: phoneNumber,\n\n      // Personal info\n      person_name: supplier.contact_name || supplier.company_name,\n\n      // Company info\n      company_name: supplier.company_name,\n      business_type: supplier.business_type,\n      cnpj: supplier.cnpj,\n\n      // Address\n      address: supplier.address,\n      city: supplier.city,\n      state: supplier.state,\n\n      // Status\n      setup_complete: true,\n\n      message: `Bem-vindo de volta, ${supplier.contact_name || supplier.company_name}! ğŸ‘‹`\n    });\n  }\n\n  // ===================================================================\n  // PASO 3: Usuario NO encontrado - Nuevo usuario\n  // ===================================================================\n\n  console.log('ğŸ“ [Check User] User NOT found - New user');\n\n  return JSON.stringify({\n    success: true,\n    registered: false,\n    user_type: null,\n\n    // IDs\n    restaurant_id: null,\n    restaurant_person_id: null,\n    supplier_id: null,\n\n    // Contact info\n    phone_number: phoneNumber,\n\n    // Status\n    setup_complete: false,\n\n    message: 'Novo usuÃ¡rio detectado. Iniciando processo de cadastro...'\n  });\n\n} catch (error) {\n  console.error('âŒ [Check User] Unexpected error:', error);\n\n  return JSON.stringify({\n    success: false,\n    registered: false,\n    error: error.message,\n    message: 'Desculpe, houve um erro ao verificar seu cadastro. Por favor, tente novamente.'\n  });\n}\n",
        "schemaType": "fromAI"
      }
    },
    {
      "id": "onboarding_restaurant_complete_1763503554746",
      "name": "onboarding_restaurant_complete",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1,
      "position": [
        800,
        500
      ],
      "parameters": {
        "name": "onboarding_restaurant_complete",
        "description": "Realiza onboarding COMPLETO de um novo restaurante. Tool conversacional multi-turn (5 passos): nome, tipo, endereÃ§o, pessoa, funÃ§Ã£o. Salva em restaurants + restaurant_people. Retorna user info completa quando finalizado.",
        "jsCode": "// ===================================================================\n// TOOL: onboarding_restaurant_complete\n// ===================================================================\n// PURPOSE: Maneja el proceso COMPLETO de onboarding de un restaurante\n//          Tool conversacional multi-turn (6 pasos)\n//          Guarda en restaurants + restaurant_people\n// ===================================================================\n\nconst input = $input.first().json;\nconst userMessage = (input.message || input.query || '').trim();\n\nconsole.log('ğŸ“ [Onboarding Restaurant] Starting...');\nconsole.log('ğŸ’¬ [Onboarding Restaurant] User message:', userMessage);\n\n// Obtener phone number del contexto del Registration Agent\n// El agent debe pasar el phone_number en el input\nconst phoneNumber = input.phone_number;\n\nif (!phoneNumber) {\n  console.error('âŒ [Onboarding Restaurant] No phone number in context');\n  return JSON.stringify({\n    success: false,\n    error: 'phone_number is required',\n    message: 'Erro interno: nÃºmero de telefone nÃ£o encontrado. Por favor, tente novamente.'\n  });\n}\n\nconsole.log('ğŸ“± [Onboarding Restaurant] Phone:', phoneNumber);\n\ntry {\n  // ===================================================================\n  // PASO 0: Obtener o crear sesiÃ³n de onboarding\n  // ===================================================================\n\n  const { data: existingSessions } = await $supabase\n    .from('line_sessions')\n    .select('*')\n    .eq('phone_number', phoneNumber)\n    .eq('session_type', 'onboarding_restaurant')\n    .eq('awaiting_continuation', true)\n    .order('created_at', { ascending: false })\n    .limit(1);\n\n  let sessionData;\n  let sessionId = null;\n\n  if (existingSessions && existingSessions.length > 0) {\n    sessionData = existingSessions[0].preferences_captured || {\n      step: 1,\n      data: {}\n    };\n    sessionId = existingSessions[0].id;\n    console.log('ğŸ“ [Onboarding Restaurant] Existing session found, step:', sessionData.step);\n  } else {\n    sessionData = {\n      step: 1,\n      data: {}\n    };\n    console.log('ğŸ“ [Onboarding Restaurant] New session created');\n  }\n\n  // ===================================================================\n  // PASO 1: Nombre del restaurante\n  // ===================================================================\n\n  if (sessionData.step === 1) {\n    if (!userMessage) {\n      // Primera vez, preguntar nombre\n      return JSON.stringify({\n        needs_user_input: true,\n        current_step: 1,\n        total_steps: 5,\n        message: \"Qual Ã© o nome do seu restaurante? ğŸ½ï¸\"\n      });\n    }\n\n    // Guardar nombre y avanzar\n    sessionData.data.restaurant_name = userMessage;\n    sessionData.step = 2;\n    await saveSession(phoneNumber, sessionData, sessionId);\n\n    return JSON.stringify({\n      needs_user_input: true,\n      current_step: 2,\n      total_steps: 5,\n      message: `Ã“timo! E qual tipo de restaurante Ã© o \"${sessionData.data.restaurant_name}\"?\\n\\nExemplos: pizzaria, churrascaria, restaurante italiano, lanchonete, comida japonesa, etc.`\n    });\n  }\n\n  // ===================================================================\n  // PASO 2: Tipo de restaurante\n  // ===================================================================\n\n  if (sessionData.step === 2) {\n    sessionData.data.restaurant_type = userMessage;\n    sessionData.step = 3;\n    await saveSession(phoneNumber, sessionData, sessionId);\n\n    return JSON.stringify({\n      needs_user_input: true,\n      current_step: 3,\n      total_steps: 5,\n      message: \"Qual Ã© o endereÃ§o completo do restaurante?\\n\\nExemplo: Rua das Flores, 123, Centro, SÃ£o Paulo, SP, 01234-567\"\n    });\n  }\n\n  // ===================================================================\n  // PASO 3: EndereÃ§o\n  // ===================================================================\n\n  if (sessionData.step === 3) {\n    sessionData.data.full_address = userMessage;\n\n    // Parse address to extract city, state, postal_code\n    const addressParts = parseAddress(userMessage);\n    sessionData.data.address = addressParts.street;\n    sessionData.data.city = addressParts.city;\n    sessionData.data.state = addressParts.state;\n    sessionData.data.postal_code = addressParts.postal_code;\n\n    sessionData.step = 4;\n    await saveSession(phoneNumber, sessionData, sessionId);\n\n    return JSON.stringify({\n      needs_user_input: true,\n      current_step: 4,\n      total_steps: 5,\n      message: \"E qual Ã© o seu nome? ğŸ‘¤\"\n    });\n  }\n\n  // ===================================================================\n  // PASO 4: Nome da pessoa\n  // ===================================================================\n\n  if (sessionData.step === 4) {\n    sessionData.data.person_name = userMessage;\n    sessionData.step = 5;\n    await saveSession(phoneNumber, sessionData, sessionId);\n\n    return JSON.stringify({\n      needs_user_input: true,\n      current_step: 5,\n      total_steps: 5,\n      message: \"Qual Ã© a sua funÃ§Ã£o no restaurante?\\n\\nExemplos: Chef, Gerente, ProprietÃ¡rio, Comprador, Cozinheiro, etc.\"\n    });\n  }\n\n  // ===================================================================\n  // PASO 5: FunÃ§Ã£o/Role - SALVAR NA BASE DE DADOS\n  // ===================================================================\n\n  if (sessionData.step === 5) {\n    sessionData.data.role = userMessage;\n\n    console.log('ğŸ’¾ [Onboarding Restaurant] Saving to database...');\n    console.log('   Data:', JSON.stringify(sessionData.data, null, 2));\n\n    // Criar restaurant\n    const { data: restaurant, error: restaurantError } = await $supabase\n      .from('restaurants')\n      .insert({\n        restaurant_name: sessionData.data.restaurant_name,\n        restaurant_type: sessionData.data.restaurant_type,\n        address: sessionData.data.address,\n        city: sessionData.data.city,\n        state: sessionData.data.state,\n        postal_code: sessionData.data.postal_code,\n        phone_number: phoneNumber,\n        is_active: true,\n        category_preferences: {} // Empty JSONB object\n      })\n      .select()\n      .single();\n\n    if (restaurantError) {\n      console.error('âŒ [Onboarding Restaurant] Error creating restaurant:', restaurantError);\n      throw new Error(`Erro ao criar restaurante: ${restaurantError.message}`);\n    }\n\n    console.log('âœ… [Onboarding Restaurant] Restaurant created, ID:', restaurant.id);\n\n    // Criar restaurant_person\n    const { data: person, error: personError } = await $supabase\n      .from('restaurant_people')\n      .insert({\n        restaurant_id: restaurant.id,\n        person_name: sessionData.data.person_name,\n        role: sessionData.data.role,\n        whatsapp_number: phoneNumber,\n        is_active: true\n      })\n      .select()\n      .single();\n\n    if (personError) {\n      console.error('âŒ [Onboarding Restaurant] Error creating person:', personError);\n      // Rollback: delete restaurant\n      await $supabase\n        .from('restaurants')\n        .delete()\n        .eq('id', restaurant.id);\n      throw new Error(`Erro ao criar pessoa: ${personError.message}`);\n    }\n\n    console.log('âœ… [Onboarding Restaurant] Person created, ID:', person.id);\n\n    // Marcar sesiÃ³n como completada\n    await $supabase\n      .from('line_sessions')\n      .update({ awaiting_continuation: false })\n      .eq('phone_number', phoneNumber)\n      .eq('session_type', 'onboarding_restaurant');\n\n    console.log('âœ… [Onboarding Restaurant] Onboarding complete!');\n\n    // Retornar success con toda la info\n    return JSON.stringify({\n      success: true,\n      onboarding_complete: true,\n\n      // User info\n      registered: true,\n      user_type: 'restaurant',\n\n      // IDs\n      restaurant_id: restaurant.id,\n      restaurant_person_id: person.id,\n      supplier_id: null,\n\n      // Contact\n      phone_number: phoneNumber,\n\n      // Personal\n      person_name: sessionData.data.person_name,\n      role: sessionData.data.role,\n\n      // Company\n      company_name: sessionData.data.restaurant_name,\n      restaurant_type: sessionData.data.restaurant_type,\n\n      // Address\n      address: sessionData.data.address,\n      city: sessionData.data.city,\n      state: sessionData.data.state,\n      postal_code: sessionData.data.postal_code,\n\n      // Status\n      setup_complete: true,\n\n      message: `Perfeito, ${sessionData.data.person_name}! âœ…\\n\\nSeu restaurante \"${sessionData.data.restaurant_name}\" estÃ¡ cadastrado no Frepi!\\n\\nAgora vocÃª jÃ¡ pode comeÃ§ar a usar o sistema! ğŸ‰`\n    });\n  }\n\n  // Se chegou aqui, algo estÃ¡ errado\n  console.error('âŒ [Onboarding Restaurant] Invalid step:', sessionData.step);\n  return JSON.stringify({\n    success: false,\n    error: 'Invalid step',\n    message: 'Erro no processo de cadastro. Vamos comeÃ§ar novamente.'\n  });\n\n} catch (error) {\n  console.error('âŒ [Onboarding Restaurant] Error:', error);\n\n  return JSON.stringify({\n    success: false,\n    error: error.message,\n    message: 'Desculpe, houve um erro ao salvar seus dados. Por favor, tente novamente.'\n  });\n}\n\n// ===================================================================\n// HELPER FUNCTIONS\n// ===================================================================\n\nasync function saveSession(phoneNumber, sessionData, sessionId) {\n  if (sessionId) {\n    // Update existing session\n    await $supabase\n      .from('line_sessions')\n      .update({\n        preferences_captured: sessionData,\n        last_activity_at: new Date().toISOString()\n      })\n      .eq('id', sessionId);\n\n    console.log('ğŸ’¾ [Session] Updated session:', sessionId);\n  } else {\n    // Create new session\n    const { data } = await $supabase\n      .from('line_sessions')\n      .insert({\n        phone_number: phoneNumber,\n        session_type: 'onboarding_restaurant',\n        awaiting_continuation: true,\n        preferences_captured: sessionData,\n        last_activity_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n\n    console.log('ğŸ’¾ [Session] Created new session:', data.id);\n  }\n}\n\nfunction parseAddress(fullAddress) {\n  // Simple address parser\n  // Expected format: \"Street, Number, Neighborhood, City, State, PostalCode\"\n  // Example: \"Rua das Flores, 123, Centro, SÃ£o Paulo, SP, 01234-567\"\n\n  const parts = fullAddress.split(',').map(p => p.trim());\n\n  let street = '';\n  let city = '';\n  let state = '';\n  let postal_code = '';\n\n  if (parts.length >= 4) {\n    // Street + Number + Neighborhood\n    street = parts.slice(0, -3).join(', ');\n    // City\n    city = parts[parts.length - 3];\n    // State\n    state = parts[parts.length - 2];\n    // Postal code (may not be present)\n    postal_code = parts[parts.length - 1];\n\n    // If postal code doesn't look like a code, it's probably part of state\n    if (postal_code && !/\\d/.test(postal_code)) {\n      state = state + ', ' + postal_code;\n      postal_code = '';\n    }\n  } else if (parts.length >= 2) {\n    street = parts[0];\n    city = parts[parts.length - 2] || '';\n    state = parts[parts.length - 1] || '';\n  } else {\n    street = fullAddress;\n  }\n\n  return {\n    street,\n    city,\n    state,\n    postal_code\n  };\n}\n",
        "schemaType": "fromAI"
      }
    },
    {
      "id": "onboarding_supplier_complete_1763503554746",
      "name": "onboarding_supplier_complete",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1,
      "position": [
        800,
        700
      ],
      "parameters": {
        "name": "onboarding_supplier_complete",
        "description": "Realiza onboarding COMPLETO de um novo fornecedor. Tool conversacional multi-turn (6 passos): empresa, tipo negÃ³cio, CNPJ, contato, endereÃ§o, categorias. Salva em suppliers. Retorna user info completa quando finalizado.",
        "jsCode": "// ===================================================================\n// TOOL: onboarding_supplier_complete\n// ===================================================================\n// PURPOSE: Maneja el proceso COMPLETO de onboarding de un fornecedor\n//          Tool conversacional multi-turn (6 pasos)\n//          Guarda en suppliers\n// ===================================================================\n\nconst input = $input.first().json;\nconst userMessage = (input.message || input.query || '').trim();\n\nconsole.log('ğŸ“ [Onboarding Supplier] Starting...');\nconsole.log('ğŸ’¬ [Onboarding Supplier] User message:', userMessage);\n\n// Obtener phone number del contexto\nconst phoneNumber = input.phone_number;\n\nif (!phoneNumber) {\n  console.error('âŒ [Onboarding Supplier] No phone number in context');\n  return JSON.stringify({\n    success: false,\n    error: 'phone_number is required',\n    message: 'Erro interno: nÃºmero de telefone nÃ£o encontrado. Por favor, tente novamente.'\n  });\n}\n\nconsole.log('ğŸ“± [Onboarding Supplier] Phone:', phoneNumber);\n\ntry {\n  // ===================================================================\n  // PASO 0: Obtener o crear sesiÃ³n de onboarding\n  // ===================================================================\n\n  const { data: existingSessions } = await $supabase\n    .from('line_sessions')\n    .select('*')\n    .eq('phone_number', phoneNumber)\n    .eq('session_type', 'onboarding_supplier')\n    .eq('awaiting_continuation', true)\n    .order('created_at', { ascending: false })\n    .limit(1);\n\n  let sessionData;\n  let sessionId = null;\n\n  if (existingSessions && existingSessions.length > 0) {\n    sessionData = existingSessions[0].preferences_captured || {\n      step: 1,\n      data: {}\n    };\n    sessionId = existingSessions[0].id;\n    console.log('ğŸ“ [Onboarding Supplier] Existing session found, step:', sessionData.step);\n  } else {\n    sessionData = {\n      step: 1,\n      data: {}\n    };\n    console.log('ğŸ“ [Onboarding Supplier] New session created');\n  }\n\n  // ===================================================================\n  // PASO 1: Nome da empresa\n  // ===================================================================\n\n  if (sessionData.step === 1) {\n    if (!userMessage) {\n      // Primera vez, preguntar nome da empresa\n      return JSON.stringify({\n        needs_user_input: true,\n        current_step: 1,\n        total_steps: 6,\n        message: \"Qual Ã© o nome da sua empresa fornecedora? ğŸ“¦\"\n      });\n    }\n\n    // Guardar nome e avanzar\n    sessionData.data.company_name = userMessage;\n    sessionData.step = 2;\n    await saveSession(phoneNumber, sessionData, sessionId);\n\n    return JSON.stringify({\n      needs_user_input: true,\n      current_step: 2,\n      total_steps: 6,\n      message: `Ã“timo! E qual Ã© o tipo de negÃ³cio da \"${sessionData.data.company_name}\"?\\n\\n1ï¸âƒ£ Distribuidor\\n2ï¸âƒ£ Produtor\\n3ï¸âƒ£ Atacadista\\n\\nResponda com 1, 2, 3 ou escreva o tipo.`\n    });\n  }\n\n  // ===================================================================\n  // PASO 2: Tipo de negÃ³cio\n  // ===================================================================\n\n  if (sessionData.step === 2) {\n    // Parse business type\n    let businessType = userMessage.toLowerCase();\n    if (businessType === '1' || businessType.includes('distribui')) {\n      businessType = 'distributor';\n    } else if (businessType === '2' || businessType.includes('produ')) {\n      businessType = 'producer';\n    } else if (businessType === '3' || businessType.includes('ataca')) {\n      businessType = 'wholesaler';\n    } else {\n      businessType = 'other';\n    }\n\n    sessionData.data.business_type = businessType;\n    sessionData.step = 3;\n    await saveSession(phoneNumber, sessionData, sessionId);\n\n    return JSON.stringify({\n      needs_user_input: true,\n      current_step: 3,\n      total_steps: 6,\n      message: \"Qual Ã© o CNPJ da empresa?\\n\\nFormato: 12.345.678/0001-90\\n\\n(Se nÃ£o tiver CNPJ, pode pular digitando 'pular')\"\n    });\n  }\n\n  // ===================================================================\n  // PASO 3: CNPJ\n  // ===================================================================\n\n  if (sessionData.step === 3) {\n    if (userMessage.toLowerCase() === 'pular') {\n      sessionData.data.cnpj = null;\n    } else {\n      sessionData.data.cnpj = userMessage;\n    }\n\n    sessionData.step = 4;\n    await saveSession(phoneNumber, sessionData, sessionId);\n\n    return JSON.stringify({\n      needs_user_input: true,\n      current_step: 4,\n      total_steps: 6,\n      message: \"Qual Ã© o nome da pessoa de contato? ğŸ‘¤\"\n    });\n  }\n\n  // ===================================================================\n  // PASO 4: Nome da pessoa de contato\n  // ===================================================================\n\n  if (sessionData.step === 4) {\n    sessionData.data.contact_name = userMessage;\n    sessionData.step = 5;\n    await saveSession(phoneNumber, sessionData, sessionId);\n\n    return JSON.stringify({\n      needs_user_input: true,\n      current_step: 5,\n      total_steps: 6,\n      message: \"Qual Ã© o endereÃ§o da empresa?\\n\\nExemplo: Rua do ComÃ©rcio, 456, Distrito Industrial, SÃ£o Paulo, SP\"\n    });\n  }\n\n  // ===================================================================\n  // PASO 5: EndereÃ§o\n  // ===================================================================\n\n  if (sessionData.step === 5) {\n    sessionData.data.full_address = userMessage;\n\n    // Parse address\n    const addressParts = parseAddress(userMessage);\n    sessionData.data.address = addressParts.street;\n    sessionData.data.city = addressParts.city;\n    sessionData.data.state = addressParts.state;\n\n    sessionData.step = 6;\n    await saveSession(phoneNumber, sessionData, sessionId);\n\n    return JSON.stringify({\n      needs_user_input: true,\n      current_step: 6,\n      total_steps: 6,\n      message: \"Por Ãºltimo, quais categorias de produtos vocÃªs fornecem?\\n\\nExemplos: carnes, laticÃ­nios, frutas e verduras, grÃ£os, bebidas, produtos de limpeza, etc.\\n\\n(Pode listar vÃ¡rios separados por vÃ­rgula)\"\n    });\n  }\n\n  // ===================================================================\n  // PASO 6: Categorias de produtos - SALVAR NA BASE DE DADOS\n  // ===================================================================\n\n  if (sessionData.step === 6) {\n    // Parse product categories\n    const categories = userMessage.split(',').map(c => c.trim()).filter(c => c);\n    sessionData.data.product_categories = categories;\n\n    console.log('ğŸ’¾ [Onboarding Supplier] Saving to database...');\n    console.log('   Data:', JSON.stringify(sessionData.data, null, 2));\n\n    // Criar supplier\n    const { data: supplier, error: supplierError } = await $supabase\n      .from('suppliers')\n      .insert({\n        company_name: sessionData.data.company_name,\n        business_type: sessionData.data.business_type,\n        cnpj: sessionData.data.cnpj,\n        contact_name: sessionData.data.contact_name,\n        phone_number: phoneNumber,\n        address: sessionData.data.address,\n        city: sessionData.data.city,\n        state: sessionData.data.state,\n        product_categories: sessionData.data.product_categories,\n        is_active: true,\n        contact_method: 'whatsapp' // Default to whatsapp since they're using WhatsApp\n      })\n      .select()\n      .single();\n\n    if (supplierError) {\n      console.error('âŒ [Onboarding Supplier] Error creating supplier:', supplierError);\n      throw new Error(`Erro ao criar fornecedor: ${supplierError.message}`);\n    }\n\n    console.log('âœ… [Onboarding Supplier] Supplier created, ID:', supplier.id);\n\n    // Marcar sesiÃ³n como completada\n    await $supabase\n      .from('line_sessions')\n      .update({ awaiting_continuation: false })\n      .eq('phone_number', phoneNumber)\n      .eq('session_type', 'onboarding_supplier');\n\n    console.log('âœ… [Onboarding Supplier] Onboarding complete!');\n\n    // Retornar success con toda la info\n    return JSON.stringify({\n      success: true,\n      onboarding_complete: true,\n\n      // User info\n      registered: true,\n      user_type: 'supplier',\n\n      // IDs\n      restaurant_id: null,\n      restaurant_person_id: null,\n      supplier_id: supplier.id,\n\n      // Contact\n      phone_number: phoneNumber,\n\n      // Personal\n      person_name: sessionData.data.contact_name,\n\n      // Company\n      company_name: sessionData.data.company_name,\n      business_type: sessionData.data.business_type,\n      cnpj: sessionData.data.cnpj,\n\n      // Address\n      address: sessionData.data.address,\n      city: sessionData.data.city,\n      state: sessionData.data.state,\n\n      // Products\n      product_categories: sessionData.data.product_categories,\n\n      // Status\n      setup_complete: true,\n\n      message: `Perfeito, ${sessionData.data.contact_name}! âœ…\\n\\nSua empresa \"${sessionData.data.company_name}\" estÃ¡ cadastrada no Frepi como fornecedor!\\n\\nAgora vocÃª jÃ¡ pode comeÃ§ar a oferecer seus produtos! ğŸ“¦ğŸ‰`\n    });\n  }\n\n  // Se chegou aqui, algo estÃ¡ errado\n  console.error('âŒ [Onboarding Supplier] Invalid step:', sessionData.step);\n  return JSON.stringify({\n    success: false,\n    error: 'Invalid step',\n    message: 'Erro no processo de cadastro. Vamos comeÃ§ar novamente.'\n  });\n\n} catch (error) {\n  console.error('âŒ [Onboarding Supplier] Error:', error);\n\n  return JSON.stringify({\n    success: false,\n    error: error.message,\n    message: 'Desculpe, houve um erro ao salvar seus dados. Por favor, tente novamente.'\n  });\n}\n\n// ===================================================================\n// HELPER FUNCTIONS\n// ===================================================================\n\nasync function saveSession(phoneNumber, sessionData, sessionId) {\n  if (sessionId) {\n    // Update existing session\n    await $supabase\n      .from('line_sessions')\n      .update({\n        preferences_captured: sessionData,\n        last_activity_at: new Date().toISOString()\n      })\n      .eq('id', sessionId);\n\n    console.log('ğŸ’¾ [Session] Updated session:', sessionId);\n  } else {\n    // Create new session\n    const { data } = await $supabase\n      .from('line_sessions')\n      .insert({\n        phone_number: phoneNumber,\n        session_type: 'onboarding_supplier',\n        awaiting_continuation: true,\n        preferences_captured: sessionData,\n        last_activity_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n\n    console.log('ğŸ’¾ [Session] Created new session:', data.id);\n  }\n}\n\nfunction parseAddress(fullAddress) {\n  // Simple address parser\n  // Expected format: \"Street, Number, Neighborhood, City, State\"\n\n  const parts = fullAddress.split(',').map(p => p.trim());\n\n  let street = '';\n  let city = '';\n  let state = '';\n\n  if (parts.length >= 3) {\n    // Street + Number + Neighborhood\n    street = parts.slice(0, -2).join(', ');\n    // City\n    city = parts[parts.length - 2];\n    // State\n    state = parts[parts.length - 1];\n  } else if (parts.length >= 2) {\n    street = parts[0];\n    city = parts[parts.length - 2] || '';\n    state = parts[parts.length - 1] || '';\n  } else {\n    street = fullAddress;\n  }\n\n  return {\n    street,\n    city,\n    state\n  };\n}\n",
        "schemaType": "fromAI"
      }
    },
    {
      "id": "registration_agent_1763503554746",
      "name": "Registration Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.6,
      "position": [
        1200,
        500
      ],
      "parameters": {
        "options": {
          "systemMessage": "# ğŸ” REGISTRATION AGENT - Frepi\n\n## TU ÃšNICA MISIÃ“N\n\nEres el agente responsable de VERIFICAR y REGISTRAR usuarios en el sistema Frepi.\nTu trabajo es CRÃTICO porque determinas quiÃ©n es el usuario antes de que interactÃºe\ncon el sistema principal.\n\n## FLUJO QUE DEBES SEGUIR\n\n### PASO 1: Verificar si usuario existe\n\n1. SIEMPRE llama primero el tool `check_user_in_database`\n   - Pasa el phone_number que recibes en el input\n2. Este tool te dirÃ¡ si el usuario ya estÃ¡ registrado o no\n\n### PASO 2: Si usuario YA EXISTE (registered: true)\n\n1. El tool ya te retornÃ³ toda su informaciÃ³n\n2. Tu trabajo estÃ¡ COMPLETO\n3. Responde al usuario con un saludo personalizado usando el person_name:\n   \"OlÃ¡ [person_name]! Bem-vindo de volta ao Frepi! ğŸ‘‹\"\n4. NO hagas nada mÃ¡s - el workflow automÃ¡ticamente lo dirigirÃ¡ al agent correcto\n\n### PASO 3: Si usuario NO EXISTE (registered: false)\n\n1. Saluda al usuario:\n   \"OlÃ¡! Bem-vindo ao Frepi! ğŸ‰\"\n\n2. Pregunta QUÃ‰ TIPO de usuario es:\n   \"Para comeÃ§ar, preciso saber:\n\n   VocÃª Ã©:\n   1ï¸âƒ£ Um restaurante (quero comprar produtos)\n   2ï¸âƒ£ Um fornecedor (quero vender produtos)\n\n   Responda com 1 ou 2, ou escreva 'restaurante' ou 'fornecedor'.\"\n\n3. ESPERA la respuesta del usuario\n\n4. Una vez que tengas la respuesta:\n   - Si eligiÃ³ \"restaurante\" (o 1 o palabras como \"comprar\", \"restaurante\"):\n     â†’ Llama `onboarding_restaurant_complete` con phone_number\n   - Si eligiÃ³ \"fornecedor\" (o 2 o palabras como \"vender\", \"fornecedor\", \"supplier\"):\n     â†’ Llama `onboarding_supplier_complete` con phone_number\n\n5. El tool de onboarding harÃ¡ una conversaciÃ³n multi-turn contigo para recopilar datos\n   - Restaurant: nombre, tipo, direcciÃ³n, persona, funciÃ³n\n   - Supplier: empresa, CNPJ, contacto, direcciÃ³n, productos\n\n6. IMPORTANTE: Pasa las respuestas del usuario al tool en cada mensaje\n   - El tool maneja el estado de la conversaciÃ³n (quÃ© paso estamos)\n   - El tool te dirÃ¡ si necesita mÃ¡s input (needs_user_input: true)\n   - Cuando el tool retorne success: true, el onboarding estÃ¡ completo\n\n7. Una vez completado el onboarding:\n   \"Perfeito! Seu cadastro estÃ¡ completo! âœ…\n\n   Agora vocÃª jÃ¡ pode usar o Frepi!\"\n\n8. Tu trabajo estÃ¡ COMPLETO\n\n## REGLAS CRÃTICAS\n\nâŒ NUNCA intentes responder preguntas sobre productos, precios, pedidos\nâŒ NUNCA hables de funcionalidades del sistema (eso es trabajo de otros agents)\nâŒ NUNCA inventes informaciÃ³n - solo usa lo que los tools te retornan\nâŒ Tu ÃšNICA responsabilidad es VERIFICAR y REGISTRAR\n\nâœ… SIEMPRE llama check_user_in_database primero (con phone_number)\nâœ… SIEMPRE sÃ© amable y claro en tus preguntas\nâœ… SIEMPRE pasa phone_number a los tools de onboarding\nâœ… SIEMPRE confirma cuando el registro estÃ© completo\n\n## DATOS DEL USUARIO ACTUAL\n\nPhone number: {{ $json.phone_number }}\nMensaje del usuario: {{ $json.message }}\n\n## IMPORTANTE: CÃ³mo llamar los tools\n\nCuando llames check_user_in_database:\n- Pasa: { \"phone_number\": \"{{ $json.phone_number }}\" }\n\nCuando llames onboarding_restaurant_complete o onboarding_supplier_complete:\n- SIEMPRE pasa el phone_number: { \"phone_number\": \"{{ $json.phone_number }}\", \"message\": \"[respuesta del usuario]\" }\n- El tool necesita el phone_number para guardar en la DB\n\n## OUTPUT ESPERADO\n\nCuando termines (usuario registrado o registro completo), el sistema\nautomÃ¡ticamente pasarÃ¡ el control al Router que dirigirÃ¡ al agent correcto.\n\nNO necesitas preocuparte por quÃ© pasa despuÃ©s - solo asegÃºrate de que\nel usuario estÃ© registrado correctamente.",
          "maxIterations": 15,
          "returnIntermediateSteps": true
        }
      }
    },
    {
      "id": "router_if_1763503554746",
      "name": "Router: Customer or Supplier",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        500
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition_restaurant",
              "leftValue": "={{ $json.user_type }}",
              "rightValue": "restaurant",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    }
  ],
  "pinData": {},
  "connections": {
    "WhatsApp Trigger": {
      "main": [
        [
          {
            "node": "Extract Message Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Message Data": {
      "main": [
        [
          {
            "node": "Registration Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Customer Journey Agent": {
      "main": [
        [
          {
            "node": "Send WhatsApp Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supplier Journey Agent": {
      "main": [
        [
          {
            "node": "Send WhatsApp Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "onboarding_restaurant": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "setup_buying_preferences": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "search_products_vector": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "build_shopping_cart": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "execute_checkout": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "show_customer_menu": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "onboarding_supplier": {
      "ai_tool": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "upload_supplier_prices": {
      "ai_tool": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "normalize_product_list": {
      "ai_tool": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "publish_to_catalog": {
      "ai_tool": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "show_supplier_menu": {
      "ai_tool": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Customer": {
      "ai_languageModel": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Supplier": {
      "ai_languageModel": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Memory Customer": {
      "ai_memory": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Memory Supplier": {
      "ai_memory": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "check_user_in_database": {
      "ai_tool": [
        [
          {
            "node": "Registration Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "onboarding_restaurant_complete": {
      "ai_tool": [
        [
          {
            "node": "Registration Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "onboarding_supplier_complete": {
      "ai_tool": [
        [
          {
            "node": "Registration Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Registration Agent": {
      "main": [
        [
          {
            "node": "Router: Customer or Supplier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router: Customer or Supplier": {
      "main": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Supplier Journey Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "frepi-mvp2-supabase-validated-v1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "49b8809ac9c6d78ac189292d079f6fecdaf436806e595e6107033a10240b1fea"
  },
  "id": "FrepiMVP2Validated",
  "tags": [
    {
      "id": "frepi-v2-supabase-validations",
      "name": "frepi-v2-validated"
    }
  ]
}