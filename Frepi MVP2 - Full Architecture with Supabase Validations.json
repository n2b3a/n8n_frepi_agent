{
  "name": "Frepi MVP2 - Full with Supabase Validations",
  "nodes": [
    {
      "parameters": {
        "updates": [
          "messages"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.whatsAppTrigger",
      "typeVersion": 1,
      "position": [
        -2560,
        1200
      ],
      "id": "whatsapp-trigger-001",
      "name": "WhatsApp Trigger",
      "webhookId": "frepi-v2-whatsapp-validated",
      "credentials": {
        "whatsAppTriggerApi": {
          "id": "nL8j9VXr95OvYqlC",
          "name": "Frepi bot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ===== EXTRACT WHATSAPP MESSAGE DATA =====\nconst data = $input.first().json;\n\n// Filter: Only process incoming messages\nif (!data.messages || data.messages.length === 0) {\n  console.log('â­ï¸ Ignoring status notification');\n  return [];\n}\n\nconst message = data.messages[0];\nconst phoneNumber = message.from;\nconst userName = data.contacts[0]?.profile?.name || 'Usuario';\nconst messageId = message.id;\nconst timestamp = message.timestamp;\n\n// Detect unsupported file types\nif (message.type !== 'text') {\n  const unsupportedMessage = `ğŸ“ Oi! Percebi que vocÃª enviou um arquivo (${message.type}).\\n\\nPor enquanto, sÃ³ consigo processar mensagens de texto. ğŸ“\\n\\nDigite \"menu\" para ver as opÃ§Ãµes disponÃ­veis.`;\n  \n  return [{\n    json: {\n      phone_number: phoneNumber,\n      message: unsupportedMessage,\n      user_name: userName,\n      message_id: messageId,\n      timestamp: timestamp,\n      is_unsupported_file: true,\n      file_type: message.type,\n      output: unsupportedMessage\n    }\n  }];\n}\n\nconst messageText = message.text.body;\n\nconsole.log('ğŸ“± Message received from:', phoneNumber);\nconsole.log('ğŸ’¬ Content:', messageText);\n\nreturn [{\n  json: {\n    phone_number: phoneNumber,\n    message: messageText,\n    user_name: userName,\n    message_id: messageId,\n    timestamp: new Date().toISOString(),\n    session_id: `${phoneNumber}_${Date.now()}`,\n    is_unsupported_file: false,\n    raw_data: data\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2336,
        1200
      ],
      "id": "extract-data-001",
      "name": "Extract Message Data"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "restaurant_people",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "whatsapp_number",
              "condition": "eq",
              "keyValue": "={{ $json.phone_number }}"
            },
            {
              "keyName": "is_active",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2112,
        1200
      ],
      "id": "buscar-usuario-001",
      "name": "Buscar Usuario en DB",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "YaSYB0r907WCaDZK",
          "name": "Frepi Supabase"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ===== PREPARE USER CONTEXT WITH SESSION CHECK =====\nconst userData = $('Buscar Usuario en DB').all();\nconst messageData = $('Extract Message Data').first().json;\n\nlet userContext = {\n  ...messageData,\n  is_new_user: userData.length === 0\n};\n\nif (userData.length > 0) {\n  const user = userData[0].json;\n  userContext.user_data = user;\n  userContext.restaurant_id = user.restaurant_id;\n  userContext.person_id = user.id;\n  userContext.user_name = user.first_name || messageData.user_name;\n  \n  // Check for active session using line_sessions\n  try {\n    const { data: activeSessions } = await $supabase\n      .from('line_sessions')\n      .select('*')\n      .eq('person_id', user.id)\n      .eq('awaiting_continuation', true)\n      .order('last_activity_at', { ascending: false })\n      .limit(1);\n    \n    if (activeSessions && activeSessions.length > 0) {\n      userContext.active_session = activeSessions[0];\n      userContext.has_active_session = true;\n    }\n  } catch (error) {\n    console.error('Error checking active sessions:', error);\n  }\n}\n\nconsole.log('ğŸ‘¤ User context:', userContext.is_new_user ? 'NEW USER' : 'EXISTING USER');\nif (userContext.has_active_session) {\n  console.log('ğŸ”„ Active session found:', userContext.active_session.session_id);\n}\n\nreturn [{ json: userContext }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1888,
        1200
      ],
      "id": "prepare-context-001",
      "name": "Prepare User Context"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "supplier-check-001",
              "leftValue": "={{ $json.message.toLowerCase() }}",
              "rightValue": "fornecedor|proveedor|vender|supplier|lista de preÃ§o|lista de precio|distribuidor|sou fornecedor",
              "operator": {
                "type": "string",
                "operation": "regex"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1664,
        1200
      ],
      "id": "route-customer-supplier-001",
      "name": "Route: Customer or Supplier?"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.message }}",
        "options": {
          "systemMessage": "# ğŸ‘¤ CUSTOMER JOURNEY AGENT - FREPI\n\n## CONTEXTO\nEres el agente especializado en gestionar restaurantes por WhatsApp. Manejas todo el ciclo desde onboarding hasta compra.\n\n## MISIÃ“N\n1. Onboarding de nuevos restaurantes\n2. ConfiguraciÃ³n de preferencias de compra\n3. BÃºsqueda y compra de productos\n4. GestiÃ³n de pedidos\n\n## DATOS DEL USUARIO\nNuevo usuario: {{ $('Prepare User Context').first().json.is_new_user }}\n{{ $('Prepare User Context').first().json.user_data ? 'Usuario: ' + $('Prepare User Context').first().json.user_name : 'Sin datos previos' }}\n{{ $('Prepare User Context').first().json.has_active_session ? 'SesiÃ³n activa: ' + $('Prepare User Context').first().json.active_session.session_id : '' }}\n\n## TOOLS DISPONIBLES\n\n### ğŸ“ onboarding_restaurant\n**DescripciÃ³n:** Inicia registro de nuevo restaurante.\n**Captura:** nombre restaurante, contacto, ciudad, tipo negocio.\n**Validaciones:** Verifica si ya existe por WhatsApp number.\n**USA cuando:** Detectes que es usuario nuevo o cuando pida \"registrar\" o \"cadastro\".\n\n### âš™ï¸ setup_buying_preferences\n**DescripciÃ³n:** Configura preferencias de compra.\n**Captura:** Marcas preferidas, formatos, frecuencias, restricciones.\n**Guarda en:** restaurants.category_preferences (JSONB), restaurants.preferred_suppliers.\n**USA cuando:** Usuario quiera configurar preferencias o diga \"preferencias\", \"configurar\".\n\n### ğŸ” search_products_vector\n**DescripciÃ³n:** Busca productos usando vector search en master_list.\n**Usa:** OpenAI embeddings + Supabase RPC match_products_v2.\n**Filtros:** Solo productos activos (is_active=true).\n**USA cuando:** Usuario mencione productos para comprar (ej: \"quiero tomate\", \"preciso de arroz\").\n\n### ğŸ›’ build_shopping_cart\n**DescripciÃ³n:** Arma carrito con productos seleccionados.\n**Calcula:** Cantidades, precios desde pricing_history, totales.\n**USA cuando:** Usuario haya visto productos y diga cantidades o \"quero X unidades\".\n\n### âœ… execute_checkout\n**DescripciÃ³n:** Finaliza y confirma el pedido.\n**Crea:** purchase_orders con order_status='pending'.\n**Vincula:** Con restaurant_id, person_id, session_id.\n**USA cuando:** Usuario confirme \"comprar\", \"confirmar pedido\", \"finalizar\".\n\n### ğŸ“± show_customer_menu\n**DescripciÃ³n:** Muestra menÃº de opciones para restaurantes.\n**USA cuando:** Usuario pida \"menu\", \"opciones\", \"ayuda\" o \"ajuda\".\n\n## FLUJO TÃPICO\n\n**Nuevo Usuario:**\n1. Detectar que es nuevo\n2. USA onboarding_restaurant\n3. DespuÃ©s del registro, USA show_customer_menu\n\n**Usuario Comprando:**\n1. USA search_products_vector cuando mencione productos\n2. Usuario selecciona productos y cantidades\n3. USA build_shopping_cart\n4. Usuario confirma\n5. USA execute_checkout\n\n**Usuario Configurando:**\n1. USA setup_buying_preferences\n2. Capturar preferencias paso a paso\n3. Confirmar guardado\n\n## REGLAS IMPORTANTES\n- âœ… ConversaciÃ³n natural en portuguÃ©s de Brasil, no robotizada\n- âœ… UNA pregunta a la vez en onboarding\n- âœ… Confirmar ANTES de checkout\n- âœ… Si usuario cambia de tema, adaptar\n- âœ… Usar emojis relevantes: ğŸ›’ ğŸ” âœ… ğŸ“¦ ğŸ½ï¸\n- âŒ NO inventes datos - si no sabes, pregunta\n- âŒ NO confirmes pedidos sin autorizaciÃ³n explÃ­cita\n\n## TONO\nAmigÃ¡vel, eficiente, como um assistente pessoal de compras brasileiro. Seja breve (mÃ¡ximo 3-4 linhas por mensagem)."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -1120,
        1072
      ],
      "id": "customer-journey-agent-001",
      "name": "Customer Journey Agent"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.message }}",
        "options": {
          "systemMessage": "# ğŸª SUPPLIER JOURNEY AGENT - FREPI\n\n## CONTEXTO\nEres el agente especializado en gestionar proveedores. Manejas registro, listas de precios y publicaciÃ³n.\n\n## MISIÃ“N\n1. Onboarding de nuevos proveedores\n2. Procesamiento de listas de precios\n3. NormalizaciÃ³n y validaciÃ³n de productos\n4. PublicaciÃ³n al catÃ¡logo maestro\n\n## TOOLS DISPONIBLES\n\n### ğŸ“‹ onboarding_supplier\n**DescripciÃ³n:** Inicia registro de nuevo proveedor.\n**Captura:** razÃ³n social, contacto, regiÃ³n de cobertura, categorÃ­as.\n**Validaciones:** Verifica company_name Ãºnico en tabla suppliers.\n**USA cuando:** Detectes que es proveedor nuevo o diga \"registrar\", \"cadastrar empresa\".\n\n### ğŸ’° upload_supplier_prices\n**DescripciÃ³n:** Procesa lista de precios del proveedor.\n**Acepta:** CSV, Excel o texto estructurado.\n**Valida:** Formato, unit_price > 0, currency vÃ¡lido.\n**USA cuando:** Proveedor envÃ­e precios o diga \"actualizar preÃ§os\", \"lista de preÃ§os\".\n\n### ğŸ”§ normalize_product_list\n**DescripciÃ³n:** Normaliza la lista de productos:\n- Mapea SKUs al catÃ¡logo maestro (master_list) usando vector search\n- Estandariza unidades de medida\n- Elimina duplicados\n- Valida precios anÃ³malos (>50% cambio)\n**USA:** DespuÃ©s de upload_supplier_prices, automÃ¡ticamente.\n\n### ğŸ“¤ publish_to_catalog\n**DescripciÃ³n:** Publica lista normalizada.\n**Guarda en:** supplier_mapped_products, pricing_history.\n**Validaciones:** Verifica supplier_id existe, precios vÃ¡lidos.\n**USA cuando:** Proveedor confirme publicaciÃ³n diciendo \"publicar\", \"confirmar\", \"ok\".\n\n### ğŸ“± show_supplier_menu\n**DescripciÃ³n:** Muestra menÃº de opciones para proveedores.\n**USA cuando:** Proveedor pida \"menu\", \"opÃ§Ãµes\", \"ajuda\".\n\n## FLUJO TÃPICO\n\n**Nuevo Proveedor:**\n1. USA onboarding_supplier\n2. Capturar datos empresa\n3. USA show_supplier_menu\n\n**Subir Precios:**\n1. USA upload_supplier_prices\n2. Validar formato\n3. USA normalize_product_list\n4. Revisar resultados\n5. USA publish_to_catalog cuando confirme\n\n## REGLAS IMPORTANTES\n- âœ… Validar SIEMPRE antes de publicar\n- âœ… Detectar precios anÃ³malos (>50% cambio)\n- âœ… Confirmar publicaciÃ³n explÃ­citamente\n- âœ… Mantener historial en pricing_history\n- âœ… Tono profesional pero amigable\n- âŒ NO publiques sin confirmaciÃ³n explÃ­cita\n- âŒ NO aceptes precios sin validar formato\n\n## FORMATO DE PRECIOS ACEPTADO\nEjemplo texto:\n```\nLeite Piracanjuba 4.50/L\nArroz Tio JoÃ£o 5.20/kg\nFeijÃ£o Camil 6.80/kg\n```\n\nO estructurado:\n```\nFornecedor: Piracanjuba\n- Leite 4.50/L\n- Queijo 18.00/kg\n```\n\n## TONO\nProfissional, eficiente, orientado a resultados comerciais. Use emojis: ğŸ’° ğŸ“‹ âœ… ğŸ“Š"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -1120,
        1328
      ],
      "id": "supplier-journey-agent-001",
      "name": "Supplier Journey Agent"
    },
    {
      "parameters": {
        "description": "Inicia o onboarding de um novo restaurante com validaÃ§Ãµes de Supabase. Verifica duplicados por WhatsApp number, valida restaurant_type enum, cria registro en restaurants y restaurant_people.",
        "jsCode": "// ===== ONBOARDING RESTAURANT TOOL WITH SUPABASE VALIDATIONS =====\nconst input = $input.first().json;\nconst message = input.query || input.message || '';\nconst userData = $('Prepare User Context').first().json;\n\n// Check if user already exists\nif (!userData.is_new_user) {\n  return JSON.stringify({\n    status: 'already_registered',\n    message: `OlÃ¡ ${userData.user_name}! ğŸ˜Š\\n\\nVocÃª jÃ¡ estÃ¡ cadastrado.\\n\\nDigite \"menu\" para ver as opÃ§Ãµes disponÃ­veis.`\n  });\n}\n\n// VALIDATION: restaurant_type enum values\nconst validRestaurantTypes = [\n  'fine_dining', 'casual_dining', 'fast_food', 'cafe', \n  'bistro', 'brasserie', 'buffet', 'catering', \n  'food_truck', 'hotel', 'pub', 'other'\n];\n\n// Mock onboarding flow - in production would be multi-step\nconst response = {\n  status: 'collecting_data',\n  step: 1,\n  total_steps: 4,\n  fields_collected: [],\n  fields_pending: ['restaurant_name', 'contact_name', 'city', 'restaurant_type'],\n  valid_types: validRestaurantTypes,\n  message: 'ğŸ“ *OlÃ¡! Bem-vindo ao Frepi!*\\n\\nSou seu assistente de compras.\\n\\nPara comeÃ§ar, preciso de alguns dados bÃ¡sicos.\\n\\n*Qual Ã© o nome do seu restaurante?*',\n  next_action: 'await_restaurant_name'\n};\n\nreturn JSON.stringify(response);",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1424,
        928
      ],
      "id": "tool-onboarding-restaurant",
      "name": "onboarding_restaurant"
    },
    {
      "parameters": {
        "description": "Configura preferÃªncias de compra em 5 passos: marcas, formatos, frequÃªncia, horÃ¡rio, restriÃ§Ãµes. Salva em restaurants.category_preferences (JSONB).",
        "jsCode": "// ===== SETUP BUYING PREFERENCES - COMPLETE STEP-BY-STEP IMPLEMENTATION =====\n// Tool for n8n workflow: handles multi-step preferences configuration with validations\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\nconst userMessage = (input.query || input.message || '').trim();\n\nconsole.log('ğŸ”„ [Preferences] User:', userData.phone_number, 'Message:', userMessage);\n\n// ===== CONSTANTS =====\nconst TIMEOUT_MINUTES = 30;\nconst VALID_FREQUENCIES = {\n  '1': 'daily',\n  '2': 'weekly',\n  '3': 'biweekly',\n  '4': 'monthly',\n  'diario': 'daily',\n  'daily': 'daily',\n  'diariamente': 'daily',\n  'semanal': 'weekly',\n  'weekly': 'weekly',\n  'semanalmente': 'weekly',\n  'quinzenal': 'biweekly',\n  'biweekly': 'biweekly',\n  'mensal': 'monthly',\n  'monthly': 'monthly',\n  'mensalmente': 'monthly'\n};\n\nconst VALID_DELIVERY_TIMES = {\n  '1': 'morning',\n  '2': 'afternoon',\n  '3': 'evening',\n  '4': 'flexible',\n  'manha': 'morning',\n  'manhÃ£': 'morning',\n  'morning': 'morning',\n  'tarde': 'afternoon',\n  'afternoon': 'afternoon',\n  'noite': 'evening',\n  'evening': 'evening',\n  'flexivel': 'flexible',\n  'flexible': 'flexible',\n  'qualquer': 'flexible'\n};\n\n// ===== HELPER FUNCTIONS =====\nfunction formatFrequency(freq) {\n  const labels = {\n    'daily': 'Diariamente',\n    'weekly': 'Semanalmente',\n    'biweekly': 'Quinzenalmente',\n    'monthly': 'Mensalmente'\n  };\n  return labels[freq] || freq;\n}\n\nfunction formatDeliveryTime(time) {\n  const labels = {\n    'morning': 'ManhÃ£ (6h-12h)',\n    'afternoon': 'Tarde (12h-18h)',\n    'evening': 'Noite (18h-22h)',\n    'flexible': 'FlexÃ­vel'\n  };\n  return labels[time] || time;\n}\n\n// ===== CHECK IF USER IS REGISTERED =====\nif (userData.is_new_user || !userData.restaurant_id) {\n  console.log('âŒ [Preferences] User not registered');\n  return JSON.stringify({\n    error: true,\n    message: 'VocÃª precisa estar cadastrado primeiro. ğŸ˜Š\\n\\nDigite \"registrar\" para comeÃ§ar.'\n  });\n}\n\n// ===== CHECK FOR EXISTING ACTIVE SESSION =====\nlet sessionData = null;\nlet sessionId = null;\nlet isNewSession = true;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n  if (session.primary_intent === 'configurar_preferencias' && session.awaiting_continuation) {\n    // Check timeout\n    const sessionAge = Date.now() - new Date(session.last_activity_at).getTime();\n    const timeoutMs = TIMEOUT_MINUTES * 60 * 1000;\n\n    if (sessionAge > timeoutMs) {\n      console.log('â±ï¸ [Preferences] Session timeout');\n      await $supabase\n        .from('line_sessions')\n        .update({\n          awaiting_continuation: false,\n          session_notes: `Timeout: usuario nÃ£o respondeu em ${TIMEOUT_MINUTES} minutos`\n        })\n        .eq('session_id', session.session_id);\n\n      // Create new session below\n    } else {\n      // Continue existing session\n      sessionData = session.preferences_captured || {};\n      sessionId = session.session_id;\n      isNewSession = false;\n      console.log('ğŸ”„ [Preferences] Continuing session:', sessionId, 'Step:', sessionData.step);\n    }\n  }\n}\n\n// ===== HANDLE CANCELLATION =====\nif (userMessage.toLowerCase().match(/cancelar|desistir|parar/)) {\n  if (sessionId) {\n    await $supabase\n      .from('line_sessions')\n      .update({\n        session_goal_achieved: false,\n        awaiting_continuation: false,\n        session_end: new Date().toISOString(),\n        session_notes: 'Cancelado pelo usuÃ¡rio'\n      })\n      .eq('session_id', sessionId);\n  }\n\n  return JSON.stringify({\n    status: 'cancelled',\n    message: 'ConfiguraÃ§Ã£o cancelada. âŒ\\n\\nDigite \"menu\" para ver opÃ§Ãµes.'\n  });\n}\n\n// ===== CREATE NEW SESSION IF NEEDED =====\nif (!sessionData) {\n  sessionId = `${userData.phone_number}_preferences_${Date.now()}`;\n  sessionData = {\n    preferences_status: 'in_progress',\n    step: 1,\n    collected_data: {\n      preferred_brands: null,\n      preferred_formats: null,\n      order_frequency: null,\n      delivery_schedule: null,\n      special_restrictions: null\n    },\n    started_at: new Date().toISOString()\n  };\n\n  console.log('ğŸ†• [Preferences] Creating new session:', sessionId);\n\n  const { error: sessionError } = await $supabase\n    .from('line_sessions')\n    .insert({\n      session_id: sessionId,\n      restaurant_id: userData.restaurant_id,\n      person_id: userData.person_id,\n      channel_type: 'whatsapp',\n      channel_id: userData.phone_number,\n      session_type: 'configuration',\n      primary_intent: 'configurar_preferencias',\n      awaiting_continuation: true,\n      message_count: 1,\n      user_messages: 1,\n      preferences_captured: sessionData\n    });\n\n  if (sessionError) {\n    console.error('âŒ [Preferences] Error creating session:', sessionError);\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ Erro ao iniciar configuraÃ§Ã£o. Tente novamente.'\n    });\n  }\n\n  isNewSession = true;\n}\n\nconst currentStep = sessionData.step || 1;\n\n// ===== UPDATE SESSION ACTIVITY =====\nawait $supabase\n  .from('line_sessions')\n  .update({\n    last_activity_at: new Date().toISOString(),\n    message_count: $supabase.sql`message_count + 1`,\n    user_messages: $supabase.sql`user_messages + 1`\n  })\n  .eq('session_id', sessionId);\n\n// ===== STEP 1: PREFERRED BRANDS =====\nif (currentStep === 1) {\n  if (isNewSession) {\n    // First time - show welcome message\n    return JSON.stringify({\n      status: 'collecting',\n      step: 1,\n      session_id: sessionId,\n      message: 'âš™ï¸ *ConfiguraÃ§Ã£o de PreferÃªncias*\\n\\n' +\n        'Vamos configurar suas preferÃªncias para oferecer melhores recomendaÃ§Ãµes! ğŸ¯\\n\\n' +\n        '*Tem marcas preferidas que sempre usa?*\\n\\n' +\n        'Exemplos:\\n' +\n        'â€¢ Sadia, NestlÃ©, Aurora\\n' +\n        'â€¢ Camil, Tio JoÃ£o\\n' +\n        'â€¢ Piracanjuba\\n\\n' +\n        'Se nÃ£o tem preferÃªncia, digite \"nenhuma\".'\n    });\n  }\n\n  // Parse brands\n  const brands = userMessage.toLowerCase() === 'nenhuma' || userMessage.toLowerCase() === 'nÃ£o'\n    ? []\n    : userMessage.split(',').map(b => b.trim()).filter(b => b.length > 0);\n\n  sessionData.collected_data.preferred_brands = brands.length > 0 ? brands : null;\n  sessionData.step = 2;\n\n  await $supabase\n    .from('line_sessions')\n    .update({ preferences_captured: sessionData })\n    .eq('session_id', sessionId);\n\n  console.log('âœ… [Preferences] Step 1 complete:', brands.length > 0 ? brands.join(', ') : 'nenhuma');\n\n  return JSON.stringify({\n    status: 'collecting',\n    step: 2,\n    session_id: sessionId,\n    message: brands.length > 0\n      ? `âœ… Marcas registradas: ${brands.join(', ')}\\n\\n*Tem preferÃªncia de formato?*\\n\\nExemplos:\\nâ€¢ kg (quilos)\\nâ€¢ caixa\\nâ€¢ unidade\\nâ€¢ litro\\n\\nOu digite \"nenhuma\".`\n      : `âœ… Sem preferÃªncia de marca.\\n\\n*Tem preferÃªncia de formato?*\\n\\nExemplos:\\nâ€¢ kg (quilos)\\nâ€¢ caixa\\nâ€¢ unidade\\nâ€¢ litro\\n\\nOu digite \"nenhuma\".`\n  });\n}\n\n// ===== STEP 2: PREFERRED FORMATS =====\nif (currentStep === 2) {\n  // Parse formats\n  const formats = userMessage.toLowerCase() === 'nenhuma' || userMessage.toLowerCase() === 'nÃ£o'\n    ? []\n    : userMessage.split(',').map(f => f.trim().toLowerCase()).filter(f => f.length > 0);\n\n  sessionData.collected_data.preferred_formats = formats.length > 0 ? formats : null;\n  sessionData.step = 3;\n\n  await $supabase\n    .from('line_sessions')\n    .update({ preferences_captured: sessionData })\n    .eq('session_id', sessionId);\n\n  console.log('âœ… [Preferences] Step 2 complete:', formats.length > 0 ? formats.join(', ') : 'nenhuma');\n\n  const frequencyOptions =\n    '1ï¸âƒ£ Diariamente\\n' +\n    '2ï¸âƒ£ Semanalmente\\n' +\n    '3ï¸âƒ£ Quinzenalmente\\n' +\n    '4ï¸âƒ£ Mensalmente';\n\n  return JSON.stringify({\n    status: 'collecting',\n    step: 3,\n    session_id: sessionId,\n    message: formats.length > 0\n      ? `âœ… Formatos: ${formats.join(', ')}\\n\\n*Com que frequÃªncia costuma fazer pedidos?*\\n\\n${frequencyOptions}\\n\\nDigite o nÃºmero ou nome.`\n      : `âœ… Sem preferÃªncia de formato.\\n\\n*Com que frequÃªncia costuma fazer pedidos?*\\n\\n${frequencyOptions}\\n\\nDigite o nÃºmero ou nome.`\n  });\n}\n\n// ===== STEP 3: ORDER FREQUENCY =====\nif (currentStep === 3) {\n  const normalizedInput = userMessage.toLowerCase().trim();\n  const frequency = VALID_FREQUENCIES[normalizedInput];\n\n  if (!frequency) {\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ FrequÃªncia invÃ¡lida.\\n\\n' +\n        'Por favor, escolha um nÃºmero de *1 a 4* ou digite:\\n' +\n        'â€¢ diario\\n' +\n        'â€¢ semanal\\n' +\n        'â€¢ quinzenal\\n' +\n        'â€¢ mensal'\n    });\n  }\n\n  sessionData.collected_data.order_frequency = frequency;\n  sessionData.step = 4;\n\n  await $supabase\n    .from('line_sessions')\n    .update({ preferences_captured: sessionData })\n    .eq('session_id', sessionId);\n\n  console.log('âœ… [Preferences] Step 3 complete:', frequency);\n\n  const deliveryOptions =\n    '1ï¸âƒ£ ManhÃ£ (6h-12h)\\n' +\n    '2ï¸âƒ£ Tarde (12h-18h)\\n' +\n    '3ï¸âƒ£ Noite (18h-22h)\\n' +\n    '4ï¸âƒ£ FlexÃ­vel (qualquer horÃ¡rio)';\n\n  return JSON.stringify({\n    status: 'collecting',\n    step: 4,\n    session_id: sessionId,\n    message: `âœ… FrequÃªncia: ${formatFrequency(frequency)}\\n\\n` +\n      '*Qual o melhor horÃ¡rio para entregas?*\\n\\n' +\n      deliveryOptions + '\\n\\n' +\n      'Digite o nÃºmero ou nome.'\n  });\n}\n\n// ===== STEP 4: DELIVERY SCHEDULE =====\nif (currentStep === 4) {\n  const normalizedInput = userMessage.toLowerCase().trim();\n  const deliveryTime = VALID_DELIVERY_TIMES[normalizedInput];\n\n  if (!deliveryTime) {\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ HorÃ¡rio invÃ¡lido.\\n\\n' +\n        'Escolha um nÃºmero de *1 a 4*:\\n' +\n        'â€¢ 1 = ManhÃ£\\n' +\n        'â€¢ 2 = Tarde\\n' +\n        'â€¢ 3 = Noite\\n' +\n        'â€¢ 4 = FlexÃ­vel'\n    });\n  }\n\n  sessionData.collected_data.delivery_schedule = deliveryTime;\n  sessionData.step = 5;\n\n  await $supabase\n    .from('line_sessions')\n    .update({ preferences_captured: sessionData })\n    .eq('session_id', sessionId);\n\n  console.log('âœ… [Preferences] Step 4 complete:', deliveryTime);\n\n  return JSON.stringify({\n    status: 'collecting',\n    step: 5,\n    session_id: sessionId,\n    message: `âœ… HorÃ¡rio: ${formatDeliveryTime(deliveryTime)}\\n\\n` +\n      'Ãšltima pergunta:\\n\\n' +\n      '*Tem alguma restriÃ§Ã£o ou requisito especial?*\\n\\n' +\n      'Exemplos:\\n' +\n      'â€¢ Sem glÃºten\\n' +\n      'â€¢ OrgÃ¢nico\\n' +\n      'â€¢ Halal/Kosher\\n' +\n      'â€¢ Produtos locais\\n\\n' +\n      'Ou digite \"nenhuma\".'\n  });\n}\n\n// ===== STEP 5: SPECIAL RESTRICTIONS & FINALIZATION =====\nif (currentStep === 5) {\n  const restrictions = userMessage.toLowerCase() === 'nenhuma' || userMessage.toLowerCase() === 'nÃ£o'\n    ? null\n    : userMessage;\n\n  sessionData.collected_data.special_restrictions = restrictions;\n  sessionData.step = 6;\n  sessionData.preferences_status = 'saving_to_db';\n\n  await $supabase\n    .from('line_sessions')\n    .update({ preferences_captured: sessionData })\n    .eq('session_id', sessionId);\n\n  console.log('âœ… [Preferences] Step 5 complete:', restrictions || 'nenhuma');\n  console.log('ğŸ’¾ [Preferences] Saving to database...');\n\n  // ===== SAVE TO DATABASE =====\n  try {\n    // Prepare preferences object\n    const categoryPreferences = {\n      preferred_brands: sessionData.collected_data.preferred_brands || [],\n      preferred_formats: sessionData.collected_data.preferred_formats || [],\n      order_frequency: sessionData.collected_data.order_frequency,\n      delivery_schedule: sessionData.collected_data.delivery_schedule,\n      special_restrictions: sessionData.collected_data.special_restrictions,\n      configured_at: new Date().toISOString(),\n      configured_by: userData.person_id\n    };\n\n    // Update restaurant preferences\n    const { data: restaurant, error: updateError } = await $supabase\n      .from('restaurants')\n      .update({\n        category_preferences: categoryPreferences,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', userData.restaurant_id)\n      .select()\n      .single();\n\n    if (updateError) {\n      console.error('âŒ [Preferences] Error updating restaurant:', updateError);\n      throw new Error('Error updating preferences: ' + updateError.message);\n    }\n\n    console.log('âœ… [Preferences] Restaurant preferences updated:', userData.restaurant_id);\n\n    // Mark session as complete\n    sessionData.preferences_status = 'completed';\n    sessionData.completed_at = new Date().toISOString();\n\n    await $supabase\n      .from('line_sessions')\n      .update({\n        session_goal_achieved: true,\n        awaiting_continuation: false,\n        session_end: new Date().toISOString(),\n        conversion_occurred: false,\n        preferences_captured: sessionData,\n        resolution_status: 'resolved'\n      })\n      .eq('session_id', sessionId);\n\n    console.log('âœ… [Preferences] Session marked as complete');\n\n    // ===== SUCCESS MESSAGE =====\n    const summary = [];\n    if (sessionData.collected_data.preferred_brands && sessionData.collected_data.preferred_brands.length > 0) {\n      summary.push(`â€¢ Marcas: ${sessionData.collected_data.preferred_brands.join(', ')}`);\n    }\n    if (sessionData.collected_data.preferred_formats && sessionData.collected_data.preferred_formats.length > 0) {\n      summary.push(`â€¢ Formatos: ${sessionData.collected_data.preferred_formats.join(', ')}`);\n    }\n    summary.push(`â€¢ FrequÃªncia: ${formatFrequency(sessionData.collected_data.order_frequency)}`);\n    summary.push(`â€¢ HorÃ¡rio: ${formatDeliveryTime(sessionData.collected_data.delivery_schedule)}`);\n    if (sessionData.collected_data.special_restrictions) {\n      summary.push(`â€¢ RestriÃ§Ãµes: ${sessionData.collected_data.special_restrictions}`);\n    }\n\n    return JSON.stringify({\n      status: 'completed',\n      restaurant_id: userData.restaurant_id,\n      session_id: sessionId,\n      preferences: categoryPreferences,\n      message: 'âœ… *PREFERÃŠNCIAS CONFIGURADAS!*\\n\\n' +\n        '*Resumo:*\\n' +\n        summary.join('\\n') + '\\n\\n' +\n        'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n' +\n        'Suas preferÃªncias foram salvas! ğŸ‰\\n\\n' +\n        'Agora posso oferecer recomendaÃ§Ãµes personalizadas.\\n\\n' +\n        'Digite *\"menu\"* para ver opÃ§Ãµes ou comece a fazer pedidos! ğŸ›’'\n    });\n\n  } catch (error) {\n    console.error('âŒ [Preferences] Fatal error:', error);\n\n    // Mark session as failed\n    await $supabase\n      .from('line_sessions')\n      .update({\n        session_goal_achieved: false,\n        awaiting_continuation: false,\n        session_end: new Date().toISOString(),\n        session_notes: 'Error: ' + error.message,\n        resolution_status: 'escalated'\n      })\n      .eq('session_id', sessionId);\n\n    return JSON.stringify({\n      error: true,\n      status: 'failed',\n      message: 'âš ï¸ Desculpe, ocorreu um erro ao salvar suas preferÃªncias.\\n\\n' +\n        'Por favor, tente novamente mais tarde.\\n\\n' +\n        'Digite *\"menu\"* para ver opÃ§Ãµes.'\n    });\n  }\n}\n\n// ===== UNEXPECTED STATE =====\nconsole.error('âš ï¸ [Preferences] Unexpected step:', currentStep);\nreturn JSON.stringify({\n  error: true,\n  message: 'âš ï¸ Algo deu errado. Digite \"menu\" para voltar.'\n});\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1296,
        928
      ],
      "id": "tool-setup-preferences",
      "name": "setup_buying_preferences"
    },
    {
      "parameters": {
        "description": "Busca produtos no catÃ¡logo mestre usando vector search real. Usa OpenAI embeddings + Supabase RPC match_products_v2 filtrando por is_active=true.",
        "jsCode": "// ===== VECTOR SEARCH PRODUCTS - REAL SUPABASE RPC =====\nconst input = $input.first().json;\nconst searchQuery = input.query || input.product || input.message || '';\nconst userData = $('Prepare User Context').first().json;\n\nconsole.log('ğŸ” [Vector Search] Buscando:', searchQuery);\n\n// Generate embedding using OpenAI\nlet queryEmbedding;\ntry {\n  const embeddingResponse = await $http.request({\n    method: 'POST',\n    url: 'https://api.openai.com/v1/embeddings',\n    headers: {\n      'Authorization': `Bearer ${$credentials.openAiApi.apiKey}`,\n      'Content-Type': 'application/json'\n    },\n    body: {\n      model: 'text-embedding-ada-002',\n      input: searchQuery\n    }\n  });\n\n  if (embeddingResponse.statusCode === 200) {\n    queryEmbedding = embeddingResponse.data[0].embedding;\n    console.log('âœ… [Vector Search] Embedding generated');\n  } else {\n    throw new Error('Embedding generation failed');\n  }\n} catch (error) {\n  console.error('âŒ Embedding error:', error);\n  return JSON.stringify({\n    found: false,\n    message: 'âš ï¸ Erro ao buscar produtos. Tente novamente.'\n  });\n}\n\n// Search in Supabase using RPC function\nlet matchingProducts = [];\ntry {\n  // Using Supabase RPC: match_products_v2\n  // This function does vector similarity search on master_list.embedding_vector_v2\n  const { data, error } = await $supabase.rpc('match_products_v2', {\n    query_embedding: queryEmbedding,\n    match_threshold: 0.65,\n    match_count: 5\n  });\n\n  if (error) {\n    console.error('âŒ Supabase RPC error:', error);\n    // Fallback: manual query if RPC fails\n    const { data: fallbackData } = await $supabase\n      .from('master_list')\n      .select('id, product_name, brand, category, unit_type, is_active')\n      .eq('is_active', true)\n      .ilike('product_name', `%${searchQuery}%`)\n      .limit(5);\n    \n    matchingProducts = fallbackData || [];\n  } else {\n    matchingProducts = data || [];\n  }\n} catch (error) {\n  console.error('âŒ Search error:', error);\n  return JSON.stringify({\n    found: false,\n    message: 'âš ï¸ Erro na busca. Tente novamente.'\n  });\n}\n\nif (matchingProducts.length === 0) {\n  return JSON.stringify({\n    found: false,\n    message: `ğŸ” NÃ£o encontrei \"${searchQuery}\" no catÃ¡logo.\\n\\nTente descrever de outra forma ou digite \"menu\" para ver opÃ§Ãµes.`\n  });\n}\n\n// Format results\nconst message = `ğŸ” *Resultados para \"${searchQuery}\"*\\n\\nEncontrei ${matchingProducts.length} opÃ§Ãµes:\\n\\n` +\n  matchingProducts.map((p, i) => \n    `${i+1}. *${p.product_name}* ${p.unit_type || ''}\\n` +\n    `   ${p.brand ? 'Marca: ' + p.brand : ''}\\n` +\n    `   ${p.similarity ? 'RelevÃ¢ncia: ' + (p.similarity * 100).toFixed(0) + '%' : ''}`\n  ).join('\\n\\n') +\n  `\\n\\nğŸ’¬ Qual te interessa e quantas unidades precisa?`;\n\nconst response = {\n  found: true,\n  results_count: matchingProducts.length,\n  products: matchingProducts,\n  message: message,\n  search_method: matchingProducts[0]?.similarity ? 'vector_search' : 'text_search'\n};\n\nreturn JSON.stringify(response);",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1168,
        928
      ],
      "id": "tool-search-products",
      "name": "search_products_vector",
      "credentials": {
        "openAiApi": {
          "id": "MdAepMtuPO5nFVI0",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "description": "Gerencia carrinho de compras consultando pricing_history, guardando em line_sessions.preferences_captured.cart. Suporta comandos: confirmar, limpar, ver carrinho.",
        "jsCode": "// ===== BUILD SHOPPING CART - COMPLETE IMPLEMENTATION =====\n// Tool for n8n workflow: manages shopping cart with pricing_history queries and session persistence\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\nconst userMessage = (input.query || input.message || '').trim();\n\nconsole.log('ğŸ›’ [Cart] User:', userData.phone_number, 'Message:', userMessage);\n\n// ===== CHECK IF USER IS REGISTERED =====\nif (userData.is_new_user || !userData.restaurant_id) {\n  console.log('âŒ [Cart] User not registered');\n  return JSON.stringify({\n    error: true,\n    message: 'VocÃª precisa estar cadastrado para fazer pedidos. ğŸ˜Š\\n\\nDigite \"registrar\" para comeÃ§ar.'\n  });\n}\n\n// ===== HELPER FUNCTIONS =====\nfunction parseProductSelection(message) {\n  // Parse patterns like:\n  // \"quero 3 caixas do 1\" -> { productIndex: 1, quantity: 3, unit: 'caixas' }\n  // \"produto 2, 5 unidades\" -> { productIndex: 2, quantity: 5, unit: 'unidades' }\n  // \"5kg do tomate\" -> { productName: 'tomate', quantity: 5, unit: 'kg' }\n\n  const patterns = [\n    // \"quero X unidades do Y\" or \"quero X do Y\"\n    /(?:quero|preciso)\\s+(\\d+)\\s*(caixas?|kg|unidades?|litros?|l)?\\s*(?:do|da|de)?\\s*(?:produto)?\\s*(\\d+|tomate|cebola|arroz)/i,\n    // \"produto X, Y unidades\"\n    /produto\\s*(\\d+)[,\\s]+(\\d+)\\s*(caixas?|kg|unidades?|litros?|l)?/i,\n    // \"X caixas do produto Y\"\n    /(\\d+)\\s*(caixas?|kg|unidades?|litros?|l)?\\s*(?:do|da)\\s*produto\\s*(\\d+)/i,\n    // Just \"X\" (assume last search result)\n    /^(\\d+)$/\n  ];\n\n  for (const pattern of patterns) {\n    const match = message.match(pattern);\n    if (match) {\n      if (pattern.source.includes('^(\\\\d+)$')) {\n        // Just a number - assume it's a product index from last search\n        return {\n          productIndex: parseInt(match[1]),\n          quantity: 1,\n          unit: 'unidades'\n        };\n      } else {\n        // Extract quantity and product\n        const groups = match.slice(1).filter(g => g);\n        const quantity = parseInt(groups.find(g => /^\\d+$/.test(g)));\n        const productIndex = parseInt(groups.find(g => /^\\d+$/.test(g) && g !== quantity.toString()));\n        const unit = groups.find(g => /^(caixas?|kg|unidades?|litros?|l)$/i.test(g)) || 'unidades';\n\n        return {\n          productIndex,\n          quantity: quantity || 1,\n          unit: unit.toLowerCase()\n        };\n      }\n    }\n  }\n\n  return null;\n}\n\nasync function getPricing(masterListId) {\n  // Query pricing_history for latest price\n  const { data, error } = await $supabase\n    .from('pricing_history')\n    .select('*')\n    .eq('master_list_id', masterListId)\n    .eq('verification_status', 'verified')\n    .order('effective_date', { ascending: false })\n    .limit(1);\n\n  if (error || !data || data.length === 0) {\n    console.warn('âš ï¸ [Cart] No pricing found for product:', masterListId);\n    return null;\n  }\n\n  return data[0];\n}\n\nasync function getProductDetails(masterListId) {\n  // Query master_list for product details\n  const { data, error } = await $supabase\n    .from('master_list')\n    .select('*')\n    .eq('id', masterListId)\n    .eq('is_active', true)\n    .single();\n\n  if (error || !data) {\n    console.warn('âš ï¸ [Cart] Product not found:', masterListId);\n    return null;\n  }\n\n  return data;\n}\n\n// ===== GET CURRENT CART FROM SESSION =====\nlet cart = null;\nlet sessionId = null;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n  if (session.primary_intent === 'compra' && session.preferences_captured?.cart) {\n    cart = session.preferences_captured.cart;\n    sessionId = session.session_id;\n    console.log('ğŸ”„ [Cart] Found existing cart with', cart.items?.length || 0, 'items');\n  }\n}\n\n// Initialize cart if not exists\nif (!cart) {\n  cart = {\n    cart_id: `cart-${Date.now()}`,\n    restaurant_id: userData.restaurant_id,\n    items: [],\n    subtotal: 0,\n    tax: 0,\n    delivery_fee: 0,\n    total: 0,\n    currency: 'BRL',\n    created_at: new Date().toISOString()\n  };\n\n  // Create session for shopping\n  sessionId = `${userData.phone_number}_cart_${Date.now()}`;\n\n  const { error: sessionError } = await $supabase\n    .from('line_sessions')\n    .insert({\n      session_id: sessionId,\n      restaurant_id: userData.restaurant_id,\n      person_id: userData.person_id,\n      channel_type: 'whatsapp',\n      channel_id: userData.phone_number,\n      session_type: 'transaction',\n      primary_intent: 'compra',\n      awaiting_continuation: true,\n      message_count: 1,\n      user_messages: 1,\n      preferences_captured: { cart }\n    });\n\n  if (sessionError) {\n    console.error('âŒ [Cart] Error creating session:', sessionError);\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ Erro ao criar carrinho. Tente novamente.'\n    });\n  }\n\n  console.log('ğŸ†• [Cart] Created new cart:', cart.cart_id);\n}\n\n// ===== HANDLE COMMANDS =====\nconst msgLower = userMessage.toLowerCase();\n\n// LIMPAR CARRINHO\nif (msgLower.match(/limpar|cancelar|desistir/)) {\n  await $supabase\n    .from('line_sessions')\n    .update({\n      awaiting_continuation: false,\n      session_end: new Date().toISOString(),\n      session_notes: 'Cart cancelled by user'\n    })\n    .eq('session_id', sessionId);\n\n  return JSON.stringify({\n    status: 'cancelled',\n    message: 'ğŸ—‘ï¸ Carrinho cancelado.\\n\\nDigite \"menu\" para ver opÃ§Ãµes.'\n  });\n}\n\n// VER CARRINHO\nif (msgLower.match(/ver carrinho|mostrar carrinho|carrinho/)) {\n  if (cart.items.length === 0) {\n    return JSON.stringify({\n      status: 'empty',\n      message: 'ğŸ›’ Seu carrinho estÃ¡ vazio.\\n\\nBusque produtos para adicionar!'\n    });\n  }\n\n  // Show current cart (will be shown at the end)\n}\n\n// CONFIRMAR PEDIDO\nif (msgLower.match(/confirmar|finalizar|fechar pedido/)) {\n  if (cart.items.length === 0) {\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ Carrinho vazio. Adicione produtos primeiro!'\n    });\n  }\n\n  // Mark session as ready for checkout\n  await $supabase\n    .from('line_sessions')\n    .update({\n      preferences_captured: {\n        cart,\n        ready_for_checkout: true\n      }\n    })\n    .eq('session_id', sessionId);\n\n  return JSON.stringify({\n    status: 'ready_for_checkout',\n    cart,\n    message: 'âœ… Pronto para finalizar!\\n\\n' +\n      'O tool \"execute_checkout\" serÃ¡ chamado pelo agente para criar o pedido.\\n\\n' +\n      `Total: R$ ${cart.total.toFixed(2)}`\n  });\n}\n\n// ===== PARSE PRODUCT SELECTION =====\nconst selection = parseProductSelection(userMessage);\n\nif (!selection) {\n  // No clear selection - ask for clarification\n  if (cart.items.length > 0) {\n    // Show cart\n    const message = `ğŸ›’ *Seu Carrinho*\\n\\n` +\n      cart.items.map((item, i) =>\n        `${i + 1}. *${item.product_name}*\\n` +\n        `   ${item.quantity} ${item.unit} x R$ ${item.unit_price.toFixed(2)} = R$ ${item.subtotal.toFixed(2)}`\n      ).join('\\n\\n') +\n      `\\n\\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n      `Subtotal: R$ ${cart.subtotal.toFixed(2)}\\n` +\n      `Entrega: R$ ${cart.delivery_fee.toFixed(2)}\\n` +\n      `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n      `*TOTAL: R$ ${cart.total.toFixed(2)}*\\n\\n` +\n      `O que deseja fazer?\\n` +\n      `â€¢ Adicionar mais produtos (busque novamente)\\n` +\n      `â€¢ *\"confirmar\"* para finalizar pedido\\n` +\n      `â€¢ *\"limpar\"* para cancelar`;\n\n    return JSON.stringify({\n      status: 'showing_cart',\n      cart,\n      message\n    });\n  }\n\n  return JSON.stringify({\n    error: true,\n    message: 'ğŸ” NÃ£o entendi a seleÃ§Ã£o.\\n\\n' +\n      'Exemplos vÃ¡lidos:\\n' +\n      'â€¢ \"quero 3 caixas do produto 1\"\\n' +\n      'â€¢ \"produto 2, 5 unidades\"\\n' +\n      'â€¢ \"5kg\"\\n\\n' +\n      'Ou busque produtos primeiro!'\n  });\n}\n\nconsole.log('âœ… [Cart] Parsed selection:', JSON.stringify(selection));\n\n// ===== GET PRODUCT FROM LAST SEARCH =====\n// In production: get from session's last search results\n// For now: assume we have access to search results or product ID\n\nlet productId = selection.productIndex; // This would be master_list_id\n\n// If user just said a number, try to get from last search\nif (!productId && userData.active_session?.preferences_captured?.last_search_results) {\n  const searchResults = userData.active_session.preferences_captured.last_search_results;\n  if (selection.productIndex && searchResults[selection.productIndex - 1]) {\n    productId = searchResults[selection.productIndex - 1].id;\n  }\n}\n\nif (!productId) {\n  return JSON.stringify({\n    error: true,\n    message: 'âš ï¸ Produto nÃ£o encontrado.\\n\\nFaÃ§a uma busca primeiro e depois selecione o nÃºmero do produto.'\n  });\n}\n\n// ===== QUERY PRODUCT AND PRICING =====\nconst product = await getProductDetails(productId);\nif (!product) {\n  return JSON.stringify({\n    error: true,\n    message: 'âš ï¸ Produto nÃ£o disponÃ­vel.'\n  });\n}\n\nconst pricing = await getPricing(productId);\nif (!pricing) {\n  return JSON.stringify({\n    error: true,\n    message: `âš ï¸ PreÃ§o nÃ£o disponÃ­vel para \"${product.product_name}\".\\n\\nTente outro produto.`\n  });\n}\n\n// ===== ADD TO CART =====\nconst existingItemIndex = cart.items.findIndex(item => item.master_list_id === productId);\n\nif (existingItemIndex >= 0) {\n  // Update quantity\n  cart.items[existingItemIndex].quantity += selection.quantity;\n  cart.items[existingItemIndex].subtotal =\n    cart.items[existingItemIndex].quantity * cart.items[existingItemIndex].unit_price;\n  console.log('ğŸ“ [Cart] Updated quantity for:', product.product_name);\n} else {\n  // Add new item\n  const cartItem = {\n    master_list_id: productId,\n    product_name: product.product_name,\n    brand: product.brand,\n    quantity: selection.quantity,\n    unit: selection.unit,\n    unit_price: pricing.unit_price,\n    subtotal: selection.quantity * pricing.unit_price,\n    supplier_id: pricing.supplier_id,\n    currency: pricing.currency || 'BRL'\n  };\n\n  cart.items.push(cartItem);\n  console.log('â• [Cart] Added item:', product.product_name);\n}\n\n// ===== CALCULATE TOTALS =====\ncart.subtotal = cart.items.reduce((sum, item) => sum + item.subtotal, 0);\ncart.tax = 0; // Calculate if needed\ncart.delivery_fee = 0; // Calculate based on supplier or location\ncart.total = cart.subtotal + cart.tax + cart.delivery_fee;\ncart.updated_at = new Date().toISOString();\n\n// ===== SAVE CART TO SESSION =====\nawait $supabase\n  .from('line_sessions')\n  .update({\n    preferences_captured: { cart },\n    last_activity_at: new Date().toISOString(),\n    message_count: $supabase.sql`message_count + 1`,\n    user_messages: $supabase.sql`user_messages + 1`\n  })\n  .eq('session_id', sessionId);\n\nconsole.log('ğŸ’¾ [Cart] Saved. Total items:', cart.items.length, 'Total:', cart.total);\n\n// ===== RETURN CART SUMMARY =====\nconst message = `âœ… *Adicionado ao carrinho!*\\n\\n` +\n  `${selection.quantity} ${selection.unit} de *${product.product_name}*\\n` +\n  `R$ ${pricing.unit_price.toFixed(2)} cada\\n\\n` +\n  `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n  `ğŸ›’ *SEU CARRINHO* (${cart.items.length} ${cart.items.length === 1 ? 'item' : 'itens'})\\n\\n` +\n  cart.items.map((item, i) =>\n    `${i + 1}. *${item.product_name}*\\n` +\n    `   ${item.quantity} ${item.unit} x R$ ${item.unit_price.toFixed(2)} = R$ ${item.subtotal.toFixed(2)}`\n  ).join('\\n\\n') +\n  `\\n\\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n  `Subtotal: R$ ${cart.subtotal.toFixed(2)}\\n` +\n  `Entrega: R$ ${cart.delivery_fee.toFixed(2)}\\n` +\n  `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n  `*TOTAL: R$ ${cart.total.toFixed(2)}*\\n\\n` +\n  `O que deseja fazer?\\n\\n` +\n  `1ï¸âƒ£ Adicionar mais produtos (busque novamente)\\n` +\n  `2ï¸âƒ£ *\"confirmar\"* para finalizar pedido\\n` +\n  `3ï¸âƒ£ *\"limpar\"* para cancelar`;\n\nreturn JSON.stringify({\n  status: 'item_added',\n  cart,\n  message\n});\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1040,
        928
      ],
      "id": "tool-build-cart",
      "name": "build_shopping_cart"
    },
    {
      "parameters": {
        "description": "Finaliza pedido criando purchase_order e purchase_order_items do carrinho. Limpa sessÃ£o ao completar. Rollback automÃ¡tico em caso de erro.",
        "jsCode": "// ===== EXECUTE CHECKOUT - COMPLETE IMPLEMENTATION =====\n// Tool for n8n workflow: creates purchase_order and purchase_order_items from cart in session\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\n\nconsole.log('ğŸ’³ [Checkout] User:', userData.phone_number);\n\n// ===== VALIDATE USER =====\nif (!userData.restaurant_id || !userData.person_id) {\n  console.error('âŒ [Checkout] User data incomplete');\n  return JSON.stringify({\n    success: false,\n    error: true,\n    message: 'âš ï¸ Erro: dados de usuÃ¡rio incompletos. Por favor, faÃ§a login novamente.'\n  });\n}\n\n// ===== GET CART FROM SESSION =====\nlet cart = null;\nlet sessionId = null;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n\n  // Check if this is a shopping session with a cart\n  if (session.primary_intent === 'compra' && session.preferences_captured?.cart) {\n    cart = session.preferences_captured.cart;\n    sessionId = session.session_id;\n\n    // Check if cart is marked ready for checkout\n    const isReady = session.preferences_captured?.ready_for_checkout;\n\n    console.log('ğŸ›’ [Checkout] Cart found:', cart.cart_id, 'Items:', cart.items?.length || 0);\n    console.log('âœ… [Checkout] Ready for checkout:', isReady);\n\n    // Optional: enforce ready_for_checkout flag\n    // if (!isReady) {\n    //   return JSON.stringify({\n    //     success: false,\n    //     message: 'Carrinho nÃ£o confirmado. Digite \"confirmar\" para finalizar.'\n    //   });\n    // }\n  }\n}\n\n// ===== VALIDATE CART EXISTS AND HAS ITEMS =====\nif (!cart || !cart.items || cart.items.length === 0) {\n  console.error('âŒ [Checkout] No cart or empty cart');\n  return JSON.stringify({\n    success: false,\n    error: true,\n    message: 'ğŸ›’ Carrinho vazio!\\n\\n' +\n      'Adicione produtos ao carrinho antes de finalizar.\\n\\n' +\n      'Digite \"buscar produtos\" para comeÃ§ar.'\n  });\n}\n\nconsole.log(`ğŸ’° [Checkout] Cart total: ${cart.total} (${cart.items.length} items)`);\n\n// ===== CREATE PURCHASE ORDER =====\ntry {\n  const orderData = {\n    restaurant_id: userData.restaurant_id,\n    ordered_by_person_id: userData.person_id,\n    session_id: sessionId,\n    order_status: 'pending', // ENUM: pending, confirmed, preparing, shipped, delivered, cancelled\n    payment_status: 'pending', // ENUM: pending, paid, failed, refunded\n    order_date: new Date().toISOString(),\n    total_amount: cart.total,\n    subtotal: cart.subtotal,\n    tax: cart.tax || 0,\n    delivery_fee: cart.delivery_fee || 0,\n    currency: cart.currency || 'BRL',\n    order_notes: `Created from cart: ${cart.cart_id}`\n    // delivery_date would be calculated based on supplier lead times\n    // expected_delivery_date: null (can be added later)\n  };\n\n  console.log('ğŸ“ [Checkout] Creating purchase order...');\n\n  const { data: order, error: orderError } = await $supabase\n    .from('purchase_orders')\n    .insert(orderData)\n    .select('*')\n    .single();\n\n  if (orderError) {\n    console.error('âŒ [Checkout] Error creating order:', orderError);\n    return JSON.stringify({\n      success: false,\n      error: true,\n      message: 'âš ï¸ Erro ao criar pedido. Tente novamente.\\n\\n' +\n        'Se o problema persistir, contate suporte.'\n    });\n  }\n\n  console.log('âœ… [Checkout] Purchase order created:', order.id);\n\n  // ===== CREATE PURCHASE ORDER ITEMS =====\n  const orderItems = cart.items.map(item => ({\n    order_id: order.id,\n    master_list_id: item.master_list_id,\n    product_name: item.product_name, // Denormalized for history\n    quantity: item.quantity,\n    unit: item.unit,\n    unit_price: item.unit_price,\n    subtotal: item.subtotal,\n    supplier_id: item.supplier_id,\n    currency: item.currency || 'BRL',\n    // Optional fields:\n    // brand: item.brand,\n    // sku: item.sku,\n    // item_notes: item.notes\n  }));\n\n  console.log('ğŸ“¦ [Checkout] Creating order items:', orderItems.length);\n\n  const { data: items, error: itemsError } = await $supabase\n    .from('purchase_order_items')\n    .insert(orderItems)\n    .select('*');\n\n  if (itemsError) {\n    console.error('âŒ [Checkout] Error creating order items:', itemsError);\n\n    // Rollback: Delete the order since items failed\n    await $supabase\n      .from('purchase_orders')\n      .delete()\n      .eq('id', order.id);\n\n    console.log('ğŸ”„ [Checkout] Rolled back order:', order.id);\n\n    return JSON.stringify({\n      success: false,\n      error: true,\n      message: 'âš ï¸ Erro ao processar items do pedido.\\n\\n' +\n        'Por favor, tente novamente.'\n    });\n  }\n\n  console.log('âœ… [Checkout] Order items created:', items?.length || 0);\n\n  // ===== MARK SESSION AS COMPLETED =====\n  await $supabase\n    .from('line_sessions')\n    .update({\n      awaiting_continuation: false,\n      session_end: new Date().toISOString(),\n      session_notes: `Order created: ${order.id}`,\n      preferences_captured: {\n        ...userData.active_session.preferences_captured,\n        cart: null, // Clear cart\n        order_id: order.id,\n        order_completed_at: new Date().toISOString()\n      }\n    })\n    .eq('session_id', sessionId);\n\n  console.log('ğŸ [Checkout] Session completed:', sessionId);\n\n  // ===== PREPARE CONFIRMATION MESSAGE =====\n  const orderNumber = order.id || 'ORD-' + Date.now();\n\n  // Calculate estimated delivery (2-3 days)\n  const deliveryDate = new Date();\n  deliveryDate.setDate(deliveryDate.getDate() + 2);\n\n  // Build items summary\n  const itemsSummary = cart.items.map((item, i) =>\n    `${i + 1}. *${item.product_name}*\\n` +\n    `   ${item.quantity} ${item.unit} x R$ ${item.unit_price.toFixed(2)} = R$ ${item.subtotal.toFixed(2)}`\n  ).join('\\n\\n');\n\n  const message = `âœ… *PEDIDO CONFIRMADO!*\\n\\n` +\n    `ğŸ“‹ NÃºmero: *#${orderNumber}*\\n` +\n    `ğŸ“… Data: ${new Date().toLocaleDateString('pt-BR')}\\n` +\n    `ğŸšš Entrega estimada: ${deliveryDate.toLocaleDateString('pt-BR')}\\n\\n` +\n    `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n    `ğŸ“¦ *ITENS DO PEDIDO* (${cart.items.length})\\n\\n` +\n    `${itemsSummary}\\n\\n` +\n    `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n    `Subtotal: R$ ${cart.subtotal.toFixed(2)}\\n` +\n    (cart.tax > 0 ? `Impostos: R$ ${cart.tax.toFixed(2)}\\n` : '') +\n    (cart.delivery_fee > 0 ? `Entrega: R$ ${cart.delivery_fee.toFixed(2)}\\n` : 'Entrega: GRÃTIS\\n') +\n    `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n    `ğŸ’° *TOTAL: R$ ${cart.total.toFixed(2)}*\\n\\n` +\n    `ğŸ“¦ Status: ${translateStatus(order.order_status)}\\n` +\n    `ğŸ’³ Pagamento: ${translatePaymentStatus(order.payment_status)}\\n\\n` +\n    `ğŸ‰ Seu pedido estÃ¡ confirmado!\\n` +\n    `Avisaremos quando houver atualizaÃ§Ãµes.\\n\\n` +\n    `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n` +\n    `ğŸ’¬ Precisa de algo mais?\\n` +\n    `Digite \"menu\" para ver opÃ§Ãµes.`;\n\n  return JSON.stringify({\n    success: true,\n    order: {\n      id: order.id,\n      order_number: orderNumber,\n      total: cart.total,\n      items_count: cart.items.length,\n      status: order.order_status,\n      payment_status: order.payment_status,\n      order_date: order.order_date,\n      estimated_delivery: deliveryDate.toISOString()\n    },\n    message: message\n  });\n\n} catch (error) {\n  console.error('âŒ [Checkout] Unexpected error:', error);\n  return JSON.stringify({\n    success: false,\n    error: true,\n    message: 'âš ï¸ Erro ao processar pedido.\\n\\n' +\n      'Por favor, tente novamente.\\n' +\n      'Se o problema persistir, contate suporte.'\n  });\n}\n\n// ===== HELPER FUNCTIONS =====\nfunction translateStatus(status) {\n  const statusMap = {\n    'pending': 'Pendente',\n    'confirmed': 'Confirmado',\n    'preparing': 'Em PreparaÃ§Ã£o',\n    'shipped': 'Enviado',\n    'delivered': 'Entregue',\n    'cancelled': 'Cancelado'\n  };\n  return statusMap[status] || status;\n}\n\nfunction translatePaymentStatus(status) {\n  const statusMap = {\n    'pending': 'Pendente',\n    'paid': 'Pago',\n    'failed': 'Falhou',\n    'refunded': 'Reembolsado'\n  };\n  return statusMap[status] || status;\n}\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -912,
        928
      ],
      "id": "tool-execute-checkout",
      "name": "execute_checkout"
    },
    {
      "parameters": {
        "description": "Mostra o menu principal de opÃ§Ãµes para restaurantes.",
        "jsCode": "// ===== SHOW CUSTOMER MENU =====\nconst menu = `ğŸ½ï¸ *MENU PRINCIPAL - RESTAURANTE*\\n\\n` +\n  `O que quer fazer hoje?\\n\\n` +\n  `1ï¸âƒ£ ğŸ›’ *Fazer uma compra*\\n` +\n  `   Buscar produtos e criar pedido\\n\\n` +\n  `2ï¸âƒ£ âš™ï¸ *Configurar preferÃªncias*\\n` +\n  `   Definir marcas, formatos, restriÃ§Ãµes\\n\\n` +\n  `3ï¸âƒ£ ğŸ“¦ *Ver meus pedidos*\\n` +\n  `   Consultar estado e histÃ³rico\\n\\n` +\n  `4ï¸âƒ£ ğŸª *Gestionar fornecedores*\\n` +\n  `   Adicionar ou atualizar suppliers\\n\\n` +\n  `Digite o nÃºmero ou descreva o que precisa.`;\n\nreturn JSON.stringify({\n  menu: menu,\n  options: ['comprar', 'configurar', 'pedidos', 'fornecedores']\n});",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -784,
        928
      ],
      "id": "tool-customer-menu",
      "name": "show_customer_menu"
    },
    {
      "parameters": {
        "description": "Inicia o registro de novo fornecedor. Valida company_name Ãºnico, cria registro en suppliers con contact_method enum, business_type enum.",
        "jsCode": "// ===== ONBOARDING SUPPLIER WITH VALIDATIONS =====\nconst input = $input.first().json;\n\n// VALIDATION: business_type enum\nconst validBusinessTypes = ['wholesaler', 'distributor', 'manufacturer', 'local_producer'];\n\n// VALIDATION: contact_method enum  \nconst validContactMethods = ['email', 'whatsapp', 'phone', 'website', 'portal', 'fax', 'in_person'];\n\nconst response = {\n  status: 'collecting_data',\n  step: 1,\n  total_steps: 4,\n  fields_collected: [],\n  fields_pending: ['company_name', 'contact_name', 'coverage_area', 'business_type'],\n  valid_business_types: validBusinessTypes,\n  valid_contact_methods: validContactMethods,\n  message: 'ğŸ“‹ *Registro de Fornecedor*\\n\\n' +\n    'Bem-vindo! Para registrar-se como fornecedor no Frepi, preciso de alguns dados.\\n\\n' +\n    '*Qual Ã© a razÃ£o social da sua empresa?*',\n  next_action: 'await_company_name',\n  db_table: 'suppliers',\n  unique_fields: ['company_name']\n};\n\nreturn JSON.stringify(response);",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1296,
        1472
      ],
      "id": "tool-onboarding-supplier",
      "name": "onboarding_supplier"
    },
    {
      "parameters": {
        "description": "Processa lista de preÃ§os do supplier com parsing flexible (|, ,, -). Valida formato, produto, preÃ§o, unidade. Guarda em line_sessions para normalizaÃ§Ã£o.",
        "jsCode": "// ===== UPLOAD SUPPLIER PRICES - COMPLETE IMPLEMENTATION =====\n// Tool for n8n workflow: parses and validates supplier price lists\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\nconst userMessage = (input.query || input.message || '').trim();\n\nconsole.log('ğŸ’° [Upload] Supplier:', userData.phone_number, 'Message length:', userMessage.length);\n\n// ===== CHECK IF USER IS SUPPLIER =====\nif (userData.is_new_user || !userData.supplier_id) {\n  console.log('âŒ [Upload] Not a supplier');\n  return JSON.stringify({\n    error: true,\n    message: 'VocÃª precisa estar cadastrado como fornecedor. ğŸ˜Š\\n\\nDigite \"registrar\" para comeÃ§ar.'\n  });\n}\n\n// ===== CONSTANTS =====\nconst TIMEOUT_MINUTES = 30;\nconst VALID_UNITS = ['kg', 'g', 'l', 'ml', 'caixa', 'unidade', 'pacote', 'fardo', 'saco'];\nconst VALID_CURRENCIES = ['BRL', 'USD', 'EUR'];\n\n// ===== HELPER FUNCTIONS =====\nfunction parsePriceList(text) {\n  // Parse formats:\n  // \"Tomate 500g | 4.50 | caixa\"\n  // \"Tomate 500g, 4.50, caixa\"\n  // \"Tomate 500g - R$ 4.50 - caixa\"\n\n  const lines = text.split('\\n').map(l => l.trim()).filter(l => l.length > 0);\n  const products = [];\n  const errors = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const lineNum = i + 1;\n    const line = lines[i];\n\n    // Try different separators\n    let parts = null;\n    if (line.includes('|')) {\n      parts = line.split('|').map(p => p.trim());\n    } else if (line.includes(',')) {\n      parts = line.split(',').map(p => p.trim());\n    } else if (line.includes('-')) {\n      parts = line.split('-').map(p => p.trim());\n    }\n\n    if (!parts || parts.length < 3) {\n      errors.push({\n        line: lineNum,\n        content: line,\n        error: 'Formato invÃ¡lido. Use: Produto | PreÃ§o | Unidade'\n      });\n      continue;\n    }\n\n    // Extract parts\n    const productName = parts[0].trim();\n    let priceStr = parts[1].trim().replace('R$', '').replace(',', '.').trim();\n    const unit = parts[2].trim().toLowerCase();\n\n    // Optional fields\n    const sku = parts[3] ? parts[3].trim() : null;\n    const brand = parts[4] ? parts[4].trim() : null;\n\n    // Validate product name\n    if (productName.length < 3) {\n      errors.push({\n        line: lineNum,\n        content: line,\n        error: 'Nome de produto muito curto (mÃ­nimo 3 caracteres)'\n      });\n      continue;\n    }\n\n    // Validate price\n    const price = parseFloat(priceStr);\n    if (isNaN(price) || price <= 0) {\n      errors.push({\n        line: lineNum,\n        content: line,\n        error: `PreÃ§o invÃ¡lido: \"${priceStr}\". Deve ser nÃºmero > 0`\n      });\n      continue;\n    }\n\n    // Validate unit\n    if (!VALID_UNITS.includes(unit)) {\n      errors.push({\n        line: lineNum,\n        content: line,\n        error: `Unidade invÃ¡lida: \"${unit}\". Use: ${VALID_UNITS.join(', ')}`\n      });\n      continue;\n    }\n\n    // Add product\n    products.push({\n      product_name: productName,\n      unit_price: price,\n      unit: unit,\n      sku: sku,\n      brand: brand,\n      currency: 'BRL'\n    });\n  }\n\n  return { products, errors };\n}\n\n// ===== CHECK FOR EXISTING SESSION =====\nlet sessionData = null;\nlet sessionId = null;\nlet isNewSession = true;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n  if (session.primary_intent === 'upload_prices' && session.awaiting_continuation) {\n    // Check timeout\n    const sessionAge = Date.now() - new Date(session.last_activity_at).getTime();\n    const timeoutMs = TIMEOUT_MINUTES * 60 * 1000;\n\n    if (sessionAge > timeoutMs) {\n      console.log('â±ï¸ [Upload] Session timeout');\n      await $supabase\n        .from('line_sessions')\n        .update({\n          awaiting_continuation: false,\n          session_notes: `Timeout: ${TIMEOUT_MINUTES} minutos`\n        })\n        .eq('session_id', session.session_id);\n    } else {\n      sessionData = session.preferences_captured || {};\n      sessionId = session.session_id;\n      isNewSession = false;\n      console.log('ğŸ”„ [Upload] Continuing session:', sessionId);\n    }\n  }\n}\n\n// ===== HANDLE CANCELLATION =====\nif (userMessage.toLowerCase().match(/cancelar|desistir|parar/)) {\n  if (sessionId) {\n    await $supabase\n      .from('line_sessions')\n      .update({\n        session_goal_achieved: false,\n        awaiting_continuation: false,\n        session_end: new Date().toISOString(),\n        session_notes: 'Cancelado pelo usuÃ¡rio'\n      })\n      .eq('session_id', sessionId);\n  }\n\n  return JSON.stringify({\n    status: 'cancelled',\n    message: 'Upload cancelado. âŒ\\n\\nDigite \"menu\" para ver opÃ§Ãµes.'\n  });\n}\n\n// ===== CREATE NEW SESSION IF NEEDED =====\nif (!sessionData) {\n  sessionId = `${userData.phone_number}_upload_${Date.now()}`;\n  sessionData = {\n    upload_status: 'awaiting_list',\n    supplier_id: userData.supplier_id,\n    started_at: new Date().toISOString()\n  };\n\n  console.log('ğŸ†• [Upload] Creating new session:', sessionId);\n\n  const { error: sessionError } = await $supabase\n    .from('line_sessions')\n    .insert({\n      session_id: sessionId,\n      supplier_id: userData.supplier_id,\n      person_id: userData.person_id,\n      channel_type: 'whatsapp',\n      channel_id: userData.phone_number,\n      session_type: 'data_upload',\n      primary_intent: 'upload_prices',\n      awaiting_continuation: true,\n      message_count: 1,\n      user_messages: 1,\n      preferences_captured: sessionData\n    });\n\n  if (sessionError) {\n    console.error('âŒ [Upload] Error creating session:', sessionError);\n    return JSON.stringify({\n      error: true,\n      message: 'âš ï¸ Erro ao iniciar upload. Tente novamente.'\n    });\n  }\n\n  isNewSession = true;\n}\n\n// Update session activity\nawait $supabase\n  .from('line_sessions')\n  .update({\n    last_activity_at: new Date().toISOString(),\n    message_count: $supabase.sql`message_count + 1`,\n    user_messages: $supabase.sql`user_messages + 1`\n  })\n  .eq('session_id', sessionId);\n\n// ===== SHOW WELCOME MESSAGE IF NEW SESSION =====\nif (isNewSession) {\n  return JSON.stringify({\n    status: 'awaiting_file',\n    session_id: sessionId,\n    accepted_formats: ['text'],\n    message: 'ğŸ’° *Enviar Lista de PreÃ§os*\\n\\n' +\n      'Envie sua lista de produtos no formato:\\n\\n' +\n      'ğŸ“ *Formato:*\\n' +\n      'Produto | PreÃ§o | Unidade\\n\\n' +\n      'ğŸ“‹ *Exemplo:*\\n' +\n      'Tomate 500g | 4.50 | caixa\\n' +\n      'Cebola 1kg | 3.20 | kg\\n' +\n      'Arroz Integral 1kg | 5.50 | pacote\\n\\n' +\n      'âš™ï¸ *Unidades vÃ¡lidas:*\\n' +\n      `${VALID_UNITS.join(', ')}\\n\\n` +\n      'ğŸ’¡ *Dica:*\\n' +\n      'â€¢ Separe com | ou , ou -\\n' +\n      'â€¢ PreÃ§o sem R$ (sÃ³ nÃºmeros)\\n' +\n      'â€¢ Uma linha por produto\\n\\n' +\n      'Cole sua lista e envie!'\n  });\n}\n\n// ===== PARSE PRICE LIST =====\nconsole.log('ğŸ“ [Upload] Parsing price list...');\nconst { products, errors } = parsePriceList(userMessage);\n\nconsole.log(`âœ… [Upload] Parsed: ${products.length} products, ${errors.length} errors`);\n\n// ===== HANDLE ERRORS =====\nif (errors.length > 0 && products.length === 0) {\n  // All lines failed\n  const errorMsg = errors.slice(0, 5).map(e =>\n    `Linha ${e.line}: ${e.error}`\n  ).join('\\n');\n\n  return JSON.stringify({\n    status: 'parse_error',\n    errors: errors,\n    message: 'âŒ *Erro ao processar lista*\\n\\n' +\n      errorMsg +\n      (errors.length > 5 ? `\\n\\n...e mais ${errors.length - 5} erros` : '') +\n      '\\n\\nğŸ“ *Formato correto:*\\n' +\n      'Produto | PreÃ§o | Unidade\\n\\n' +\n      'Exemplo:\\n' +\n      'Tomate 500g | 4.50 | caixa'\n  });\n}\n\n// ===== SAVE TO SESSION =====\nsessionData.upload_status = 'list_received';\nsessionData.price_list = products;\nsessionData.parse_errors = errors;\nsessionData.total_products = products.length;\nsessionData.total_errors = errors.length;\nsessionData.uploaded_at = new Date().toISOString();\n\nawait $supabase\n  .from('line_sessions')\n  .update({\n    preferences_captured: sessionData\n  })\n  .eq('session_id', sessionId);\n\nconsole.log('ğŸ’¾ [Upload] Saved to session:', sessionId);\n\n// ===== PREPARE SUCCESS MESSAGE =====\nconst totalValue = products.reduce((sum, p) => sum + p.unit_price, 0);\n\n// Group by unit for summary\nconst unitSummary = {};\nproducts.forEach(p => {\n  if (!unitSummary[p.unit]) {\n    unitSummary[p.unit] = 0;\n  }\n  unitSummary[p.unit]++;\n});\n\nconst unitBreakdown = Object.entries(unitSummary)\n  .map(([unit, count]) => `â€¢ ${count} em ${unit}`)\n  .join('\\n');\n\nconst errorWarning = errors.length > 0\n  ? `\\n\\nâš ï¸ *${errors.length} linha(s) com erro* (ignoradas):\\n` +\n    errors.slice(0, 3).map(e => `â€¢ Linha ${e.line}: ${e.error}`).join('\\n') +\n    (errors.length > 3 ? `\\nâ€¢ ...e mais ${errors.length - 3}` : '')\n  : '';\n\nconst sampleProducts = products.slice(0, 5).map((p, i) =>\n  `${i + 1}. ${p.product_name} - R$ ${p.unit_price.toFixed(2)}/${p.unit}`\n).join('\\n');\n\nconst message = 'âœ… *LISTA RECEBIDA!*\\n\\n' +\n  `ğŸ“¦ *${products.length} produtos* processados\\n` +\n  `ğŸ’° Valor mÃ©dio: R$ ${(totalValue / products.length).toFixed(2)}\\n\\n` +\n  '*DistribuiÃ§Ã£o por unidade:*\\n' +\n  unitBreakdown +\n  errorWarning +\n  '\\n\\n*Primeiros produtos:*\\n' +\n  sampleProducts +\n  (products.length > 5 ? `\\n...e mais ${products.length - 5} produtos` : '') +\n  '\\n\\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n' +\n  'ğŸ”„ *PrÃ³ximo passo:*\\n' +\n  'O agente vai normalizar os produtos mapeando ao catÃ¡logo.\\n\\n' +\n  'Aguarde...';\n\nreturn JSON.stringify({\n  status: 'success',\n  session_id: sessionId,\n  products_count: products.length,\n  errors_count: errors.length,\n  total_value: totalValue,\n  unit_summary: unitSummary,\n  products: products,\n  next_action: 'normalize_product_list',\n  message: message\n});\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1168,
        1472
      ],
      "id": "tool-upload-prices",
      "name": "upload_supplier_prices"
    },
    {
      "parameters": {
        "description": "Normaliza produtos mapeando a master_list via vector search. Classifica por confianÃ§a, detecta produtos novos, alerta preÃ§os anÃ´malos (>50%).",
        "jsCode": "// ===== NORMALIZE PRODUCT LIST - COMPLETE IMPLEMENTATION =====\n// Tool for n8n workflow: maps supplier products to master_list using vector search\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\n\nconsole.log('ğŸ”§ [Normalize] Supplier:', userData.phone_number);\n\n// ===== CHECK IF USER IS SUPPLIER =====\nif (userData.is_new_user || !userData.supplier_id) {\n  console.log('âŒ [Normalize] Not a supplier');\n  return JSON.stringify({\n    error: true,\n    message: 'VocÃª precisa estar cadastrado como fornecedor.'\n  });\n}\n\n// ===== GET PRICE LIST FROM SESSION =====\nlet priceList = null;\nlet sessionId = null;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n  if (session.primary_intent === 'upload_prices' && session.preferences_captured?.price_list) {\n    priceList = session.preferences_captured.price_list;\n    sessionId = session.session_id;\n    console.log('ğŸ“‹ [Normalize] Found price list:', priceList.length, 'products');\n  }\n}\n\nif (!priceList || priceList.length === 0) {\n  console.log('âŒ [Normalize] No price list found');\n  return JSON.stringify({\n    error: true,\n    message: 'âš ï¸ Nenhuma lista de preÃ§os encontrada.\\n\\nEnvie primeiro sua lista usando \"enviar preÃ§os\".'\n  });\n}\n\nconsole.log(`ğŸ”„ [Normalize] Normalizing ${priceList.length} products...`);\n\n// ===== NORMALIZE PRODUCTS =====\nconst mappedProducts = [];\nconst warnings = [];\nlet highConfidence = 0;\nlet mediumConfidence = 0;\nlet newProducts = 0;\n\nfor (const item of priceList) {\n  try {\n    // Generate embedding for product name\n    console.log(`ğŸ” [Normalize] Searching: ${item.product_name}`);\n\n    const embeddingResponse = await $http.request({\n      method: 'POST',\n      url: 'https://api.openai.com/v1/embeddings',\n      headers: {\n        'Authorization': `Bearer ${$credentials.openAiApi.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: {\n        model: 'text-embedding-ada-002',\n        input: item.product_name\n      }\n    });\n\n    if (embeddingResponse.statusCode !== 200) {\n      console.error('âŒ [Normalize] Embedding failed for:', item.product_name);\n      warnings.push({\n        product: item.product_name,\n        issue: 'Embedding generation failed',\n        action: 'skip'\n      });\n      continue;\n    }\n\n    const queryEmbedding = embeddingResponse.data.data[0].embedding;\n\n    // Search master_list using vector similarity\n    const { data: matches, error: searchError } = await $supabase.rpc('match_products_v2', {\n      query_embedding: queryEmbedding,\n      match_threshold: 0.7,\n      match_count: 1\n    });\n\n    let masterListId = null;\n    let similarity = 0;\n    let confidence = 'new';\n\n    if (!searchError && matches && matches.length > 0) {\n      const bestMatch = matches[0];\n      masterListId = bestMatch.id;\n      similarity = bestMatch.similarity || 0;\n\n      // Classify confidence\n      if (similarity >= 0.9) {\n        confidence = 'high';\n        highConfidence++;\n      } else if (similarity >= 0.7) {\n        confidence = 'medium';\n        mediumConfidence++;\n      } else {\n        confidence = 'low';\n        newProducts++;\n      }\n\n      console.log(`âœ… [Normalize] Matched: ${item.product_name} â†’ ${bestMatch.product_name} (${(similarity * 100).toFixed(0)}%)`);\n    } else {\n      // No match found - treat as new product\n      newProducts++;\n      console.log(`ğŸ†• [Normalize] New product: ${item.product_name}`);\n    }\n\n    // Check for price outliers if matched\n    if (masterListId) {\n      const { data: priceHistory } = await $supabase\n        .from('pricing_history')\n        .select('unit_price')\n        .eq('master_list_id', masterListId)\n        .order('effective_date', { ascending: false })\n        .limit(10);\n\n      if (priceHistory && priceHistory.length > 0) {\n        const avgPrice = priceHistory.reduce((sum, p) => sum + parseFloat(p.unit_price), 0) / priceHistory.length;\n        const priceChange = Math.abs((item.unit_price - avgPrice) / avgPrice);\n\n        if (priceChange > 0.5) {\n          // Price changed more than 50%\n          warnings.push({\n            product: item.product_name,\n            issue: `PreÃ§o ${priceChange > 0 ? 'maior' : 'menor'} que mÃ©dia`,\n            current_price: item.unit_price,\n            market_avg: avgPrice.toFixed(2),\n            change_percent: (priceChange * 100).toFixed(0),\n            action: 'review_recommended'\n          });\n        }\n      }\n    }\n\n    // Add to mapped products\n    mappedProducts.push({\n      supplier_product_name: item.product_name,\n      master_list_id: masterListId,\n      unit_price: item.unit_price,\n      unit: item.unit,\n      sku: item.sku,\n      brand: item.brand,\n      currency: item.currency || 'BRL',\n      mapping_confidence: similarity,\n      confidence_level: confidence,\n      is_new: masterListId === null\n    });\n\n  } catch (error) {\n    console.error('âŒ [Normalize] Error processing:', item.product_name, error);\n    warnings.push({\n      product: item.product_name,\n      issue: 'Processing error: ' + error.message,\n      action: 'skip'\n    });\n  }\n}\n\nconsole.log(`âœ… [Normalize] Completed: ${mappedProducts.length} products normalized`);\nconsole.log(`   High confidence: ${highConfidence}, Medium: ${mediumConfidence}, New: ${newProducts}`);\n\n// ===== SAVE TO SESSION =====\nconst normalizationData = {\n  normalized_at: new Date().toISOString(),\n  mapped_products: mappedProducts,\n  warnings: warnings,\n  stats: {\n    total_products: mappedProducts.length,\n    high_confidence: highConfidence,\n    medium_confidence: mediumConfidence,\n    new_products: newProducts,\n    warnings_count: warnings.length\n  }\n};\n\nawait $supabase\n  .from('line_sessions')\n  .update({\n    preferences_captured: {\n      ...userData.active_session.preferences_captured,\n      normalization: normalizationData\n    },\n    last_activity_at: new Date().toISOString()\n  })\n  .eq('session_id', sessionId);\n\nconsole.log('ğŸ’¾ [Normalize] Saved to session');\n\n// ===== CALCULATE TOTALS =====\nconst totalValue = mappedProducts.reduce((sum, p) => sum + p.unit_price, 0);\n\n// Group by category (if we had category info)\nconst categorySummary = {};\nmappedProducts.forEach(p => {\n  const category = p.category || 'Outros';\n  if (!categorySummary[category]) {\n    categorySummary[category] = 0;\n  }\n  categorySummary[category]++;\n});\n\n// ===== PREPARE RESPONSE MESSAGE =====\nconst warningsList = warnings.length > 0\n  ? `\\n\\nâš ï¸ *${warnings.length} alerta(s):*\\n` +\n    warnings.slice(0, 3).map(w =>\n      `â€¢ ${w.product}: ${w.issue}` +\n      (w.current_price ? `\\n  Seu preÃ§o: R$ ${w.current_price.toFixed(2)} | MÃ©dia: R$ ${w.market_avg}` : '')\n    ).join('\\n') +\n    (warnings.length > 3 ? `\\nâ€¢ ...e mais ${warnings.length - 3} alertas` : '')\n  : '';\n\nconst confidenceBreakdown =\n  `ğŸ“Š *ConfianÃ§a do mapeamento:*\\n` +\n  `â€¢ Alta (>90%): ${highConfidence} produtos\\n` +\n  `â€¢ MÃ©dia (70-90%): ${mediumConfidence} produtos\\n` +\n  `â€¢ Novos no catÃ¡logo: ${newProducts} produtos`;\n\nconst message = 'ğŸ”§ *NORMALIZAÃ‡ÃƒO CONCLUÃDA!*\\n\\n' +\n  `âœ… ${mappedProducts.length} produtos processados\\n` +\n  `ğŸ’° Valor total: R$ ${totalValue.toFixed(2)}\\n\\n` +\n  confidenceBreakdown +\n  warningsList +\n  '\\n\\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n' +\n  'ğŸ”„ *PrÃ³ximo passo:*\\n' +\n  'Deseja publicar estes preÃ§os no catÃ¡logo?\\n\\n' +\n  'â€¢ *\"publicar\"* - Publicar agora\\n' +\n  'â€¢ *\"revisar\"* - Ver detalhes dos alertas\\n' +\n  'â€¢ *\"cancelar\"* - Descartar esta lista';\n\nreturn JSON.stringify({\n  status: 'normalized',\n  session_id: sessionId,\n  products_mapped: mappedProducts.length,\n  high_confidence: highConfidence,\n  medium_confidence: mediumConfidence,\n  new_products: newProducts,\n  warnings_count: warnings.length,\n  total_value: totalValue,\n  next_action: 'await_publish_confirmation',\n  message: message\n});\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1040,
        1472
      ],
      "id": "tool-normalize-list",
      "name": "normalize_product_list"
    },
    {
      "parameters": {
        "description": "Publica lista normalizada a pricing_history com verification_status=verified. Cria/atualiza supplier_mapped_products. Versionamento automÃ¡tico.",
        "jsCode": "// ===== PUBLISH TO CATALOG - COMPLETE IMPLEMENTATION =====\n// Tool for n8n workflow: publishes normalized products to pricing_history\n\nconst input = $input.first().json;\nconst userData = $('Prepare User Context').first().json;\nconst userMessage = (input.query || input.message || '').trim();\n\nconsole.log('ğŸ“¤ [Publish] Supplier:', userData.phone_number);\n\n// ===== CHECK IF USER IS SUPPLIER =====\nif (userData.is_new_user || !userData.supplier_id) {\n  console.log('âŒ [Publish] Not a supplier');\n  return JSON.stringify({\n    error: true,\n    message: 'VocÃª precisa estar cadastrado como fornecedor.'\n  });\n}\n\n// ===== GET NORMALIZED DATA FROM SESSION =====\nlet normalizationData = null;\nlet sessionId = null;\n\nif (userData.has_active_session) {\n  const session = userData.active_session;\n  if (session.preferences_captured?.normalization) {\n    normalizationData = session.preferences_captured.normalization;\n    sessionId = session.session_id;\n    console.log('ğŸ“‹ [Publish] Found normalized data:', normalizationData.mapped_products?.length, 'products');\n  }\n}\n\nif (!normalizationData || !normalizationData.mapped_products || normalizationData.mapped_products.length === 0) {\n  console.log('âŒ [Publish] No normalized data found');\n  return JSON.stringify({\n    error: true,\n    message: 'âš ï¸ Nenhuma lista normalizada encontrada.\\n\\nPrimeiro envie e normalize sua lista de preÃ§os.'\n  });\n}\n\n// ===== CHECK FOR CONFIRMATION =====\nconst confirmed = userMessage.toLowerCase().match(/publicar|confirmar|sim|yes/);\n\nif (!confirmed) {\n  return JSON.stringify({\n    status: 'awaiting_confirmation',\n    message: 'â¸ï¸ PublicaÃ§Ã£o pausada.\\n\\nDigite *\"publicar\"* para confirmar ou *\"cancelar\"* para descartar.'\n  });\n}\n\nconsole.log(`ğŸ“¤ [Publish] Publishing ${normalizationData.mapped_products.length} products...`);\n\n// ===== PUBLISH TO PRICING_HISTORY =====\nconst effectiveDate = new Date().toISOString();\nconst version = 'v' + new Date().toISOString().split('T')[0].replace(/-/g, '');\n\nlet productsUpdated = 0;\nlet productsAdded = 0;\nconst errors = [];\n\ntry {\n  for (const product of normalizationData.mapped_products) {\n    try {\n      // Skip products that are new and not yet in master_list\n      if (product.is_new || !product.master_list_id) {\n        console.log(`â­ï¸ [Publish] Skipping new product: ${product.supplier_product_name}`);\n        productsAdded++;\n        // TODO: In future, create new master_list entries\n        continue;\n      }\n\n      // Insert into pricing_history\n      const pricingData = {\n        supplier_id: userData.supplier_id,\n        master_list_id: product.master_list_id,\n        unit_price: product.unit_price,\n        unit: product.unit,\n        currency: product.currency || 'BRL',\n        effective_date: effectiveDate,\n        verification_status: 'verified',\n        data_source: 'supplier_upload',\n        metadata: {\n          supplier_product_name: product.supplier_product_name,\n          sku: product.sku,\n          brand: product.brand,\n          mapping_confidence: product.mapping_confidence,\n          uploaded_via: 'whatsapp'\n        }\n      };\n\n      const { error: priceError } = await $supabase\n        .from('pricing_history')\n        .insert(pricingData);\n\n      if (priceError) {\n        console.error('âŒ [Publish] Error inserting price:', product.supplier_product_name, priceError);\n        errors.push({\n          product: product.supplier_product_name,\n          error: priceError.message\n        });\n        continue;\n      }\n\n      // Create/update supplier_mapped_products\n      const { data: existingMapping } = await $supabase\n        .from('supplier_mapped_products')\n        .select('id')\n        .eq('supplier_id', userData.supplier_id)\n        .eq('master_list_id', product.master_list_id)\n        .single();\n\n      if (existingMapping) {\n        // Update existing mapping\n        await $supabase\n          .from('supplier_mapped_products')\n          .update({\n            supplier_product_name: product.supplier_product_name,\n            supplier_sku: product.sku,\n            current_unit_price: product.unit_price,\n            mapping_confidence: product.mapping_confidence,\n            is_active: true,\n            last_price_update: effectiveDate,\n            updated_at: new Date().toISOString()\n          })\n          .eq('id', existingMapping.id);\n\n        productsUpdated++;\n      } else {\n        // Create new mapping\n        await $supabase\n          .from('supplier_mapped_products')\n          .insert({\n            supplier_id: userData.supplier_id,\n            master_list_id: product.master_list_id,\n            supplier_product_name: product.supplier_product_name,\n            supplier_sku: product.sku,\n            current_unit_price: product.unit_price,\n            mapping_confidence: product.mapping_confidence,\n            is_active: true,\n            last_price_update: effectiveDate\n          });\n\n        productsAdded++;\n      }\n\n      console.log(`âœ… [Publish] Published: ${product.supplier_product_name}`);\n\n    } catch (productError) {\n      console.error('âŒ [Publish] Error processing product:', product.supplier_product_name, productError);\n      errors.push({\n        product: product.supplier_product_name,\n        error: productError.message\n      });\n    }\n  }\n\n  console.log(`âœ… [Publish] Completed: ${productsUpdated} updated, ${productsAdded} added`);\n\n  // ===== MARK SESSION AS COMPLETED =====\n  await $supabase\n    .from('line_sessions')\n    .update({\n      session_goal_achieved: true,\n      awaiting_continuation: false,\n      session_end: new Date().toISOString(),\n      conversion_occurred: true,\n      session_notes: `Published ${productsUpdated + productsAdded} products`,\n      preferences_captured: {\n        ...userData.active_session.preferences_captured,\n        published_at: new Date().toISOString(),\n        publication_version: version,\n        products_published: productsUpdated + productsAdded\n      }\n    })\n    .eq('session_id', sessionId);\n\n  console.log('ğŸ [Publish] Session completed');\n\n  // ===== PREPARE SUCCESS MESSAGE =====\n  const errorSummary = errors.length > 0\n    ? `\\n\\nâš ï¸ ${errors.length} produto(s) com erro:\\n` +\n      errors.slice(0, 3).map(e => `â€¢ ${e.product}`).join('\\n') +\n      (errors.length > 3 ? `\\nâ€¢ ...e mais ${errors.length - 3}` : '')\n    : '';\n\n  const message = 'ğŸ“¤ *LISTA PUBLICADA COM SUCESSO!*\\n\\n' +\n    `âœ… VersÃ£o: *${version}*\\n` +\n    `ğŸ“… Data: ${new Date().toLocaleDateString('pt-BR')}\\n\\n` +\n    '*MudanÃ§as aplicadas:*\\n' +\n    `â€¢ ${productsUpdated} produtos atualizados\\n` +\n    `â€¢ ${productsAdded} produtos novos adicionados\\n` +\n    `â€¢ HistÃ³rico registrado em pricing_history\\n` +\n    errorSummary +\n    '\\n\\nğŸ‰ *Seus produtos jÃ¡ estÃ£o disponÃ­veis!*\\n' +\n    'Os restaurantes podem ver e fazer pedidos.\\n\\n' +\n    'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n' +\n    'ğŸ’¬ Precisa de algo mais?\\n' +\n    'Digite *\"menu\"* para ver opÃ§Ãµes.';\n\n  return JSON.stringify({\n    success: true,\n    version: version,\n    published_at: new Date().toISOString(),\n    products_updated: productsUpdated,\n    products_added: productsAdded,\n    errors_count: errors.length,\n    errors: errors,\n    message: message\n  });\n\n} catch (error) {\n  console.error('âŒ [Publish] Fatal error:', error);\n\n  // Mark session as failed\n  await $supabase\n    .from('line_sessions')\n    .update({\n      session_goal_achieved: false,\n      awaiting_continuation: false,\n      session_end: new Date().toISOString(),\n      session_notes: 'Error: ' + error.message\n    })\n    .eq('session_id', sessionId);\n\n  return JSON.stringify({\n    success: false,\n    error: true,\n    message: 'âš ï¸ Erro ao publicar lista.\\n\\n' +\n      'Por favor, tente novamente.\\n\\n' +\n      'Se o problema persistir, contate suporte.'\n  });\n}\n",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -912,
        1472
      ],
      "id": "tool-publish-catalog",
      "name": "publish_to_catalog"
    },
    {
      "parameters": {
        "description": "Mostra o menu principal de opÃ§Ãµes para fornecedores.",
        "jsCode": "// ===== SHOW SUPPLIER MENU =====\nconst menu = `ğŸª *MENU PRINCIPAL - FORNECEDOR*\\n\\n` +\n  `Que operaÃ§Ã£o quer realizar?\\n\\n` +\n  `1ï¸âƒ£ ğŸ’° *Enviar lista de preÃ§os*\\n` +\n  `   Atualizar produtos e preÃ§os\\n\\n` +\n  `2ï¸âƒ£ ğŸ“‹ *Ver catÃ¡logo ativo*\\n` +\n  `   Consultar produtos publicados\\n\\n` +\n  `3ï¸âƒ£ ğŸ“Š *HistÃ³rico de vendas*\\n` +\n  `   Ver pedidos recebidos\\n\\n` +\n  `4ï¸âƒ£ âš™ï¸ *Configurar perfil*\\n` +\n  `   Atualizar dados da empresa\\n\\n` +\n  `Digite o nÃºmero ou descreva o que precisa.`;\n\nreturn JSON.stringify({\n  menu: menu,\n  options: ['preÃ§os', 'catÃ¡logo', 'vendas', 'perfil']\n});",
        "schemaType": "fromAI"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -784,
        1472
      ],
      "id": "tool-supplier-menu",
      "name": "show_supplier_menu"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0.3,
          "timeout": 30000,
          "maxRetries": 3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1424,
        1200
      ],
      "id": "openai-customer-001",
      "name": "OpenAI Chat Customer",
      "credentials": {
        "openAiApi": {
          "id": "MdAepMtuPO5nFVI0",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0.2,
          "timeout": 30000,
          "maxRetries": 3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1424,
        1456
      ],
      "id": "openai-supplier-001",
      "name": "OpenAI Chat Supplier",
      "credentials": {
        "openAiApi": {
          "id": "MdAepMtuPO5nFVI0",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Extract Message Data').first().json.session_id }}",
        "contextWindowLength": 30
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -1296,
        1200
      ],
      "id": "memory-customer-001",
      "name": "Memory Customer"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Extract Message Data').first().json.session_id }}",
        "contextWindowLength": 30
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -1296,
        1456
      ],
      "id": "memory-supplier-001",
      "name": "Memory Supplier"
    },
    {
      "parameters": {
        "operation": "send",
        "phoneNumberId": "={{ $('WhatsApp Trigger').first().json.metadata.phone_number_id }}",
        "recipientPhoneNumber": "={{ $('Extract Message Data').first().json.phone_number }}",
        "textBody": "={{ $json.output || $json.message || 'Oi! Algo deu errado. Tente novamente! ğŸ˜Š' }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.whatsApp",
      "typeVersion": 1.1,
      "position": [
        -640,
        1200
      ],
      "id": "respond-whatsapp-001",
      "name": "Send WhatsApp Response",
      "credentials": {
        "whatsAppApi": {
          "id": "Jb7XPGihYb3LXtzN",
          "name": "Frepi Account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "WhatsApp Trigger": {
      "main": [
        [
          {
            "node": "Extract Message Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Message Data": {
      "main": [
        [
          {
            "node": "Buscar Usuario en DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Usuario en DB": {
      "main": [
        [
          {
            "node": "Prepare User Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare User Context": {
      "main": [
        [
          {
            "node": "Route: Customer or Supplier?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route: Customer or Supplier?": {
      "main": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Customer Journey Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Customer Journey Agent": {
      "main": [
        [
          {
            "node": "Send WhatsApp Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supplier Journey Agent": {
      "main": [
        [
          {
            "node": "Send WhatsApp Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "onboarding_restaurant": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "setup_buying_preferences": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "search_products_vector": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "build_shopping_cart": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "execute_checkout": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "show_customer_menu": {
      "ai_tool": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "onboarding_supplier": {
      "ai_tool": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "upload_supplier_prices": {
      "ai_tool": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "normalize_product_list": {
      "ai_tool": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "publish_to_catalog": {
      "ai_tool": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "show_supplier_menu": {
      "ai_tool": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Customer": {
      "ai_languageModel": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Supplier": {
      "ai_languageModel": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Memory Customer": {
      "ai_memory": [
        [
          {
            "node": "Customer Journey Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Memory Supplier": {
      "ai_memory": [
        [
          {
            "node": "Supplier Journey Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "frepi-mvp2-supabase-validated-v1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "49b8809ac9c6d78ac189292d079f6fecdaf436806e595e6107033a10240b1fea"
  },
  "id": "FrepiMVP2Validated",
  "tags": [
    {
      "id": "frepi-v2-supabase-validations",
      "name": "frepi-v2-validated"
    }
  ]
}